<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRObet - NFL Predictions (Beta)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 1rem;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 0.5rem;
            color: #3498db;
            font-weight: 900;
        }

        .tagline {
            color: #95a5a6;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            font-weight: 500;
        }

        .week-indicator {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #3498db;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .api-setup {
            background: rgba(52, 152, 219, 0.1);
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .api-setup h3 {
            margin-bottom: 1rem;
            color: #3498db;
        }

        .api-setup input {
            width: 100%;
            max-width: 400px;
            padding: 0.75rem;
            margin: 1rem 0;
            border-radius: 0.5rem;
            border: 2px solid rgba(52, 152, 219, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1rem;
        }

        .api-setup button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .api-setup button:hover {
            transform: scale(1.05);
        }

        .scoreboard {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }

        .scoreboard-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .stats {
            display: flex;
            gap: 2rem;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            color: #95a5a6;
            margin-top: 0.25rem;
            font-size: 0.9rem;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            font-size: 1.2rem;
            color: #3498db;
        }

        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid rgba(231, 76, 60, 0.5);
            color: #e74c3c;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 500px), 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .game-card {
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .game-card:hover {
            transform: translateY(-5px);
        }

        .game-header {
            padding: 1.5rem;
            color: white;
        }

        .game-meta {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .confidence-high {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .confidence-low {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .fallback-badge {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
        }

        .teams {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 1rem;
        }

        .team {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .team-logo {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .team-name {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .team-record {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .vs {
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 0.5;
        }

        .game-body {
            background: rgba(0, 0, 0, 0.4);
            padding: 1.5rem;
        }

        .winner-section {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .winner-label {
            font-size: 0.9rem;
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        .winner-name {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .confidence {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .rationale {
            margin-top: 1rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: left;
        }

        .rationale-item {
            padding: 0.35rem 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .prediction-section {
            margin-top: 1.5rem;
        }

        .prediction-title {
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: #3498db;
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .pred-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
        }

        .pred-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 0.5rem;
        }

        .pred-value {
            font-size: 2rem;
            font-weight: bold;
            color: #3498db;
        }

        .stats-breakdown {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .matchup-edge {
            background: rgba(52, 152, 219, 0.2);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            border-left: 3px solid #3498db;
        }

        .edge-item {
            font-size: 0.9rem;
        }

        .injuries {
            margin-top: 0.75rem;
        }

        .injury-item {
            font-size: 0.85rem;
            padding: 0.25rem 0;
            opacity: 0.9;
        }

        .injury-item a {
            color: #3498db;
            text-decoration: none;
        }

        .injury-item a:hover {
            text-decoration: underline;
        }

        .footer {
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 3rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #95a5a6;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .disclaimer {
            max-width: 800px;
            margin: 1rem auto 0;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* Upset alert badge */
        .upset-alert {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Live game badge */
        .live-badge {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            animation: pulse 2s infinite;
            font-weight: bold;
        }

        /* Winner/Loser result badges */
        .result-winner {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            font-size: 1.2rem;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            animation: slideIn 0.5s ease-out;
        }

        .result-loser {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            font-size: 1.2rem;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Live scores display */
        .live-scores {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        .live-score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0.5rem 0;
            font-size: 1.3rem;
            font-weight: bold;
        }

        .live-score-row.winning {
            color: #27ae60;
        }

        .game-status {
            text-align: center;
            font-size: 0.9rem;
            color: #3498db;
            margin-top: 0.5rem;
            font-weight: bold;
        }

        /* Team name hover/click for Elo graph */
        .team-name {
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
        }

        .team-name:hover {
            color: #3498db;
            text-decoration: underline;
        }

        /* Elo chart tooltip */
        .elo-chart {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 1rem;
            z-index: 1000;
            min-width: 300px;
            max-width: 400px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .elo-chart.show {
            opacity: 1;
            pointer-events: auto;
        }

        .elo-chart.sticky {
            pointer-events: auto;
        }

        .elo-chart-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #3498db;
            font-size: 1.1rem;
        }

        .elo-chart-canvas {
            width: 100%;
            height: 150px;
            margin: 0.5rem 0;
        }

        .elo-current {
            text-align: center;
            font-size: 1.5rem;
            color: #3498db;
            font-weight: bold;
        }

        /* Modal for game details */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            border: 2px solid #3498db;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.5rem;
        }

        .modal-close:hover {
            color: #3498db;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #3498db;
        }

        .modal-section {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
        }

        .modal-section-title {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        /* Team accuracy stats */
        .team-accuracy {
            background: rgba(52, 152, 219, 0.1);
            border-left: 3px solid #3498db;
            padding: 0.5rem;
            margin: 0.5rem 0;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .team-accuracy-good {
            border-left-color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
        }

        .team-accuracy-bad {
            border-left-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* Week Results section */
        .week-results {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .week-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .week-results-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .week-results-toggle {
            font-size: 1.5rem;
            transition: transform 0.3s;
        }

        .week-results-toggle.expanded {
            transform: rotate(180deg);
        }

        .week-results-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .week-results-content.expanded {
            max-height: 2000px;
            margin-top: 1rem;
        }

        .result-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .result-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .result-item.correct {
            border-left: 4px solid #27ae60;
        }

        .result-item.incorrect {
            border-left: 4px solid #e74c3c;
        }

        .result-icon {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .result-icon.correct {
            color: #27ae60;
        }

        .result-icon.incorrect {
            color: #e74c3c;
        }

        .result-teams {
            flex: 1;
            margin-left: 1rem;
        }

        .result-score {
            font-size: 0.9rem;
            color: #95a5a6;
        }

        @media (max-width: 768px) {
            .teams {
                flex-direction: column;
            }

            .stats {
                gap: 1rem;
                flex-wrap: wrap;
                justify-content: center;
            }

            .stat-value {
                font-size: 2rem;
            }

            .game-meta {
                justify-content: center;
            }

            .prediction-grid {
                grid-template-columns: 1fr;
            }

            .scoreboard-content {
                flex-direction: column;
                text-align: center;
            }

            .elo-chart {
                max-width: 90vw;
                left: 5vw !important;
            }

            .modal-content {
                margin: 1rem;
                padding: 1.5rem;
            }

            h1 {
                font-size: 2rem !important;
            }

            .tagline {
                font-size: 0.9rem !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèà BRObet <span style="font-size: 0.4em; color: #95a5a6; font-weight: 400;">v0.05</span></h1>
            <p class="tagline">Advanced NFL Predictions & Matchup Analysis</p>
            <div class="week-indicator" id="weekIndicator">Loading...</div>
        </header>

        <div class="api-setup" id="apiSetup">
            <h3>üîë The Odds API Key Required</h3>
            <p style="color: #95a5a6;">
                Get your free API key from <a href="https://the-odds-api.com/" target="_blank" style="color: #3498db;">the-odds-api.com</a>
            </p>
            <input type="text" id="apiKeyInput" placeholder="Enter your API key here" />
            <button onclick="saveApiKey()">Save & Load Predictions</button>
        </div>

        <div class="scoreboard">
            <div class="scoreboard-content">
                <div>
                    <h2>üìà Prediction Accuracy</h2>
                    <p style="color: #95a5a6;">Season Performance</p>
                </div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="correct">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="total">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
        <div id="loading" class="loading">Enter your API key to load predictions...</div>
        <div id="picksummary" class="scoreboard" style="display: none;">
            <h2 style="margin-bottom: 1rem;">üéØ Top Picks</h2>
            <div id="picks-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.75rem;"></div>
        </div>

        <div id="weekresults" class="week-results" style="display: none;">
            <div class="week-results-header" onclick="toggleWeekResults()">
                <h2 id="weekresults-title">üìä Week Results: 0-0 (0%)</h2>
                <span class="week-results-toggle" id="weekresults-toggle">‚ñº</span>
            </div>
            <div class="week-results-content" id="weekresults-content">
                <div id="weekresults-list"></div>
            </div>
        </div>

        <div id="games" class="games-grid"></div>

        <footer class="footer">
            <div>¬© 2025 BRObet. All rights reserved.</div>
            <div class="disclaimer">
                <strong>DISCLAIMER:</strong> This website is for informational and entertainment purposes only.
                BRObet provides NFL game predictions and analysis based on statistical models and publicly available data.
                No guarantees are made regarding the accuracy of predictions. Sports betting involves risk, and you should never
                wager more than you can afford to lose. We are not responsible for any losses incurred through the use of
                information provided on this site. Users assume all risk and liability for their betting decisions.
                This site does not operate as a gambling service and does not accept wagers. Please gamble responsibly and
                consult local laws regarding sports betting in your jurisdiction. By using this site, you acknowledge and
                agree to these terms.
            </div>
        </footer>
    </div>

    <!-- Elo Chart Tooltip -->
    <div id="eloChart" class="elo-chart"></div>

    <!-- Game Details Modal -->
    <div id="gameModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div id="modalBody"></div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        let apiKey = localStorage.getItem('nfl_odds_api_key') || '';
        let predictions = JSON.parse(localStorage.getItem('nfl_predictions') || '{}');
        let accuracyStats = { correct: 0, total: 0 }; // Will be loaded from results.json

        // Team data (logos only - all stats fetched dynamically)
        const TEAM_DATA = {
            "Arizona Cardinals": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ari.png", color: "#97233F", lat: 33.5276, lon: -112.2626 },
            "Atlanta Falcons": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/atl.png", color: "#A71930", lat: 33.7554, lon: -84.4008 },
            "Baltimore Ravens": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/bal.png", color: "#241773", lat: 39.2780, lon: -76.6227 },
            "Buffalo Bills": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/buf.png", color: "#00338D", lat: 42.7738, lon: -78.7870 },
            "Carolina Panthers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/car.png", color: "#0085CA", lat: 35.2258, lon: -80.8530 },
            "Chicago Bears": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/chi.png", color: "#0B162A", lat: 41.8623, lon: -87.6167 },
            "Cincinnati Bengals": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/cin.png", color: "#FB4F14", lat: 39.0954, lon: -84.5160 },
            "Cleveland Browns": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/cle.png", color: "#311D00", lat: 41.5061, lon: -81.6995 },
            "Dallas Cowboys": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/dal.png", color: "#003594", lat: 32.7473, lon: -97.0945 },
            "Denver Broncos": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/den.png", color: "#FB4F14", lat: 39.7439, lon: -105.0201 },
            "Detroit Lions": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/det.png", color: "#0076B6", lat: 42.3400, lon: -83.0456 },
            "Green Bay Packers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/gb.png", color: "#203731", lat: 44.5013, lon: -88.0622 },
            "Houston Texans": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/hou.png", color: "#03202F", lat: 29.6847, lon: -95.4107 },
            "Indianapolis Colts": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ind.png", color: "#002C5F", lat: 39.7601, lon: -86.1639 },
            "Jacksonville Jaguars": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/jax.png", color: "#006778", lat: 30.3240, lon: -81.6373 },
            "Kansas City Chiefs": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/kc.png", color: "#E31837", lat: 39.0489, lon: -94.4839 },
            "Las Vegas Raiders": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lv.png", color: "#000000", lat: 36.0908, lon: -115.1831 },
            "Los Angeles Chargers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lac.png", color: "#0080C6", lat: 33.9535, lon: -118.3390 },
            "Los Angeles Rams": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lar.png", color: "#003594", lat: 33.9535, lon: -118.3390 },
            "Miami Dolphins": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/mia.png", color: "#008E97", lat: 25.9580, lon: -80.2389 },
            "Minnesota Vikings": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/min.png", color: "#4F2683", lat: 44.9738, lon: -93.2577 },
            "New England Patriots": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ne.png", color: "#002244", lat: 42.0909, lon: -71.2643 },
            "New Orleans Saints": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/no.png", color: "#D3BC8D", lat: 29.9511, lon: -90.0812 },
            "New York Giants": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/nyg.png", color: "#0B2265", lat: 40.8128, lon: -74.0742 },
            "New York Jets": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/nyj.png", color: "#125740", lat: 40.8128, lon: -74.0742 },
            "Philadelphia Eagles": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/phi.png", color: "#004C54", lat: 39.9008, lon: -75.1675 },
            "Pittsburgh Steelers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/pit.png", color: "#FFB612", lat: 40.4468, lon: -80.0158 },
            "San Francisco 49ers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/sf.png", color: "#AA0000", lat: 37.4032, lon: -121.9697 },
            "Seattle Seahawks": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/sea.png", color: "#002244", lat: 47.5952, lon: -122.3316 },
            "Tampa Bay Buccaneers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/tb.png", color: "#D50A0A", lat: 27.9759, lon: -82.5033 },
            "Tennessee Titans": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ten.png", color: "#0C2340", lat: 36.1665, lon: -86.7713 },
            "Washington Commanders": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/wsh.png", color: "#5A1414", lat: 38.9076, lon: -76.8645 }
        };

        // League stats cache (comprehensive team statistics & rankings)
        let leagueStats = {
            teams: {}, // Will store comprehensive stats for each team
            rankings: {}, // Will store rankings (1-32) for each category
            hasData: false,
            lastUpdated: null
        };

        let injuries = {};
        let weeklyEloData = null; // Weekly Elo snapshots for trend graphs
        let teamAccuracy = {}; // Track prediction accuracy by team

        // ===== LOAD WEEKLY ELO DATA =====
        async function loadWeeklyEloData() {
            try {
                const response = await fetch('weekly-elo.json');
                if (response.ok) {
                    weeklyEloData = await response.json();
                    console.log(`üìà Loaded ${weeklyEloData.weeks} weeks of Elo data`);
                }
            } catch (error) {
                console.log('Could not load weekly Elo data');
            }
        }

        // ===== CALCULATE TEAM ACCURACY =====
        async function calculateTeamAccuracy() {
            try {
                const response = await fetch('test-results.json');
                if (response.ok) {
                    const data = await response.json();

                    // Initialize counters for all teams
                    for (const teamName in TEAM_DATA) {
                        teamAccuracy[teamName] = { correct: 0, total: 0 };
                    }

                    // Count correct/total for each team
                    for (const game of data.games || []) {
                        if (teamAccuracy[game.homeTeam]) {
                            teamAccuracy[game.homeTeam].total++;
                            if (game.correct) teamAccuracy[game.homeTeam].correct++;
                        }
                        if (teamAccuracy[game.awayTeam]) {
                            teamAccuracy[game.awayTeam].total++;
                            if (game.correct) teamAccuracy[game.awayTeam].correct++;
                        }
                    }

                    console.log('üìä Calculated accuracy for all teams');
                }
            } catch (error) {
                console.log('Could not calculate team accuracy');
            }
        }

        // ===== FETCH GLOBAL ACCURACY =====
        async function fetchGlobalAccuracy() {
            try {
                const response = await fetch('results.json');
                if (response.ok) {
                    const data = await response.json();
                    accuracyStats = {
                        correct: data.correct || 0,
                        total: data.total || 0
                    };
                    updateAccuracyDisplay();
                    console.log(`üìä Loaded global accuracy: ${data.correct}/${data.total} (${data.accuracy}%)`);
                } else {
                    console.log('üìä No results.json found, starting with 0% accuracy');
                    updateAccuracyDisplay();
                }
            } catch (error) {
                console.log('üìä Could not load global accuracy, starting with 0%');
                updateAccuracyDisplay();
            }
        }

        // ===== INITIALIZATION =====
        // Load global accuracy and supporting data
        fetchGlobalAccuracy();
        loadWeeklyEloData();
        calculateTeamAccuracy();

        if (apiKey) {
            document.getElementById('apiKeyInput').value = apiKey;
            document.getElementById('apiSetup').style.display = 'none';
            loadAllData();
        }

        function saveApiKey() {
            const input = document.getElementById('apiKeyInput');
            apiKey = input.value.trim();
            if (apiKey) {
                localStorage.setItem('nfl_odds_api_key', apiKey);
                document.getElementById('apiSetup').style.display = 'none';
                loadAllData();
            } else {
                showError('Please enter a valid API key');
            }
        }

        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => errorEl.style.display = 'none', 10000);
        }

        function updateAccuracyDisplay() {
            document.getElementById('correct').textContent = accuracyStats.correct;
            document.getElementById('total').textContent = accuracyStats.total;
            const accuracy = accuracyStats.total > 0 ? ((accuracyStats.correct / accuracyStats.total) * 100).toFixed(1) : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }

        // ===== MAIN DATA LOADING =====
        async function loadAllData() {
            try {
                document.getElementById('loading').textContent = 'üèà Loading NFL data...';
                console.log('=== STARTING DATA LOAD ===');

                // Step 1: Fetch league-wide team stats
                await fetchLeagueStats();

                // Step 2: Fetch injuries
                await fetchInjuries();

                // Step 3: Fetch upcoming games
                const games = await fetchGames();

                if (games.length === 0) {
                    const weekNum = data.week?.number || 'current';
                    document.getElementById('loading').textContent = `Week ${weekNum} games have concluded. New predictions will be available for next week's games.`;
                    return;
                }

                // Step 4: Fetch odds
                let oddsData = [];
                try {
                    oddsData = await fetchOdds();
                } catch (e) {
                    console.warn('Could not fetch odds:', e.message);
                }

                // Step 5: Refresh global accuracy (GitHub Actions updates this)
                await fetchGlobalAccuracy();

                // Step 6: Display games with predictions
                await displayGames(games, oddsData);

                // Step 7: Start auto-refresh for live game updates
                startAutoRefresh();

                document.getElementById('loading').style.display = 'none';
                console.log('=== DATA LOAD COMPLETE ===');
            } catch (error) {
                console.error('Error loading data:', error);
                showError('Failed to load data: ' + error.message);
                document.getElementById('loading').textContent = 'Error loading data. Check console.';
            }
        }

        // ===== FETCH LEAGUE STATS =====
        async function fetchLeagueStats() {
            console.log('üìä Calculating comprehensive team statistics from season games...');

            try {
                // Initialize team stats trackers
                const teamStats = {};
                for (const teamName in TEAM_DATA) {
                    teamStats[teamName] = {
                        pointsScored: 0,
                        pointsAllowed: 0,
                        rushYards: 0,
                        rushYardsAllowed: 0,
                        passYards: 0,
                        passYardsAllowed: 0,
                        thirdDownConversions: 0,
                        thirdDownAttempts: 0,
                        redZoneScores: 0,
                        redZoneAttempts: 0,
                        sacksAllowed: 0,
                        sacksTaken: 0,
                        turnovers: 0,
                        takeaways: 0,
                        gamesPlayed: 0
                    };
                }

                // Fetch completed games from all weeks of the season
                const currentWeek = 15; // Update as season progresses
                let totalGames = 0;
                let statsProcessed = 0;

                for (let week = 1; week <= currentWeek; week++) {
                    try {
                        document.getElementById('loading').textContent = `üèà Loading Week ${week} of ${currentWeek}...`;

                        const response = await fetch(`https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2025&seasontype=2&week=${week}`);
                        const data = await response.json();

                        for (const event of data.events || []) {
                            const competition = event.competitions[0];

                            // Only process completed games
                            if (competition.status.type.completed) {
                                const homeComp = competition.competitors.find(c => c.homeAway === 'home');
                                const awayComp = competition.competitors.find(c => c.homeAway === 'away');

                                const homeTeam = homeComp.team.displayName;
                                const awayTeam = awayComp.team.displayName;

                                // Basic scores (from scoreboard)
                                const homeScore = parseInt(homeComp.score) || 0;
                                const awayScore = parseInt(awayComp.score) || 0;

                                if (teamStats[homeTeam]) {
                                    teamStats[homeTeam].pointsScored += homeScore;
                                    teamStats[homeTeam].pointsAllowed += awayScore;
                                    teamStats[homeTeam].gamesPlayed++;
                                }

                                if (teamStats[awayTeam]) {
                                    teamStats[awayTeam].pointsScored += awayScore;
                                    teamStats[awayTeam].pointsAllowed += homeScore;
                                    teamStats[awayTeam].gamesPlayed++;
                                }

                                // Fetch detailed statistics from box score
                                try {
                                    const statsUrl = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=${event.id}`;
                                    const statsResponse = await fetch(statsUrl);
                                    const statsData = await statsResponse.json();

                                    const boxscore = statsData.boxscore;
                                    if (boxscore && boxscore.teams) {
                                        const homeStats = boxscore.teams.find(t => t.homeAway === 'home');
                                        const awayStats = boxscore.teams.find(t => t.homeAway === 'away');

                                        // Temporary objects to store yards before assigning to defense
                                        const homeYards = { rush: 0, pass: 0 };
                                        const awayYards = { rush: 0, pass: 0 };

                                        // Parse offensive statistics for both teams
                                        if (homeStats && homeStats.statistics) {
                                            parseTeamStats(homeStats.statistics, teamStats[homeTeam], homeYards);
                                        }
                                        if (awayStats && awayStats.statistics) {
                                            parseTeamStats(awayStats.statistics, teamStats[awayTeam], awayYards);
                                        }

                                        // Assign defensive stats (opponent's yards = yards allowed)
                                        if (teamStats[homeTeam]) {
                                            teamStats[homeTeam].rushYardsAllowed += awayYards.rush;
                                            teamStats[homeTeam].passYardsAllowed += awayYards.pass;
                                        }
                                        if (teamStats[awayTeam]) {
                                            teamStats[awayTeam].rushYardsAllowed += homeYards.rush;
                                            teamStats[awayTeam].passYardsAllowed += homeYards.pass;
                                        }

                                        statsProcessed++;
                                    }
                                } catch (statErr) {
                                    console.warn(`Could not fetch stats for game ${event.id}:`, statErr.message);
                                }

                                totalGames++;
                            }
                        }
                    } catch (err) {
                        console.warn(`Could not fetch week ${week}:`, err.message);
                    }
                }

                console.log(`‚úÖ Processed ${totalGames} completed games, ${statsProcessed} with detailed stats`);

                document.getElementById('loading').textContent = `üìä Calculating team rankings and statistics...`;

                // Calculate per-game averages and percentages
                for (const teamName in teamStats) {
                    const stats = teamStats[teamName];
                    if (stats.gamesPlayed > 0) {
                        leagueStats.teams[teamName] = {
                            // Basic ratings
                            offensiveRating: stats.pointsScored / stats.gamesPlayed,
                            defensiveRating: stats.pointsAllowed / stats.gamesPlayed,

                            // Rushing stats
                            rushYPG: stats.rushYards / stats.gamesPlayed,
                            rushDefYPG: stats.rushYardsAllowed / stats.gamesPlayed,

                            // Passing stats
                            passYPG: stats.passYards / stats.gamesPlayed,
                            passDefYPG: stats.passYardsAllowed / stats.gamesPlayed,

                            // Situational stats
                            thirdDownPct: stats.thirdDownAttempts > 0 ? (stats.thirdDownConversions / stats.thirdDownAttempts) * 100 : 40,
                            redZonePct: stats.redZoneAttempts > 0 ? (stats.redZoneScores / stats.redZoneAttempts) * 100 : 50,

                            // Sacks
                            sacksAllowedPG: stats.sacksAllowed / stats.gamesPlayed,
                            sacksTakenPG: stats.sacksTaken / stats.gamesPlayed,

                            // Turnovers
                            turnoverDiff: stats.takeaways - stats.turnovers,

                            // Raw totals (for ranking)
                            gamesPlayed: stats.gamesPlayed
                        };
                    } else {
                        // Fallback defaults
                        leagueStats.teams[teamName] = {
                            offensiveRating: 24, defensiveRating: 24,
                            rushYPG: 120, rushDefYPG: 120,
                            passYPG: 220, passDefYPG: 220,
                            thirdDownPct: 40, redZonePct: 50,
                            sacksAllowedPG: 2.5, sacksTakenPG: 2.5,
                            turnoverDiff: 0, gamesPlayed: 0
                        };
                    }
                }

                // Calculate rankings (1-32) for each category
                calculateRankings();

                leagueStats.hasData = totalGames > 0;
                leagueStats.lastUpdated = new Date().toISOString();

                // Log sample for verification
                const sampleTeams = ['Detroit Lions', 'Buffalo Bills', 'Kansas City Chiefs'];
                sampleTeams.forEach(team => {
                    if (leagueStats.teams[team] && leagueStats.rankings[team]) {
                        const stats = leagueStats.teams[team];
                        const ranks = leagueStats.rankings[team];
                        console.log(`${team}: OFF #${ranks.rushOffRank} rush, #${ranks.passOffRank} pass | DEF #${ranks.rushDefRank} rush, #${ranks.passDefRank} pass`);
                    }
                });

                console.log(`‚úÖ Calculated comprehensive stats for ${Object.keys(leagueStats.teams).length} teams`);

            } catch (error) {
                console.error('Failed to calculate team stats:', error);
                // Fallback: use league average for all teams
                for (const teamName in TEAM_DATA) {
                    leagueStats.teams[teamName] = {
                        offensiveRating: 24, defensiveRating: 24,
                        rushYPG: 120, rushDefYPG: 120,
                        passYPG: 220, passDefYPG: 220,
                        thirdDownPct: 40, redZonePct: 50,
                        sacksAllowedPG: 2.5, sacksTakenPG: 2.5,
                        turnoverDiff: 0, gamesPlayed: 0
                    };
                    leagueStats.rankings[teamName] = {
                        rushOffRank: 16, passOffRank: 16,
                        rushDefRank: 16, passDefRank: 16
                    };
                }
                leagueStats.hasData = false;
            }
        }

        // Parse team statistics from box score
        function parseTeamStats(statistics, teamStats, yards) {
            // DEBUG: Log all stat names we see (only once)
            if (!window.statNamesLogged) {
                console.log('üìã Box score stat names available:', statistics.map(s => s.name).join(', '));
                window.statNamesLogged = true;
            }

            for (const stat of statistics) {
                const name = stat.name.toLowerCase();
                const value = parseFloat(stat.displayValue) || 0;

                if (name === 'rushingyards' || name === 'rushing yards' || name === 'totalrushingyards') {
                    teamStats.rushYards += value;
                    if (yards) yards.rush = value;
                }
                else if (name === 'passingyards' || name === 'passing yards' || name === 'totalpassingyards' || name === 'netpassingyards') {
                    teamStats.passYards += value;
                    if (yards) yards.pass = value;
                }
                else if (name === 'thirddowneff') {
                    // Format is "X-Y" where X is conversions, Y is attempts
                    const parts = stat.displayValue.split('-');
                    if (parts.length === 2) {
                        teamStats.thirdDownConversions += parseInt(parts[0]) || 0;
                        teamStats.thirdDownAttempts += parseInt(parts[1]) || 0;
                    }
                }
                else if (name === 'redzoneeff' || name === 'redzonemade-att') {
                    const parts = stat.displayValue.split('-');
                    if (parts.length === 2) {
                        teamStats.redZoneScores += parseInt(parts[0]) || 0;
                        teamStats.redZoneAttempts += parseInt(parts[1]) || 0;
                    }
                }
                else if (name === 'sacks' || name === 'sacks-yardslost') {
                    // This is sacks ALLOWED by the offense
                    const parts = stat.displayValue.split('-');
                    teamStats.sacksAllowed += parseInt(parts[0]) || 0;
                }
                else if (name === 'interceptions' || name === 'interceptionthrown') {
                    teamStats.turnovers += value;
                }
                else if (name === 'fumblelost' || name === 'fumbleslost') {
                    teamStats.turnovers += value;
                }
                else if (name === 'defensiveinterceptions') {
                    teamStats.takeaways += value;
                }
                else if (name === 'defensivefumblerecoveries' || name === 'fumblerecoveries') {
                    teamStats.takeaways += value;
                }
                else if (name === 'defensivesacks' || name === 'totalsacks') {
                    teamStats.sacksTaken += value;
                }
            }

            // Defensive yards allowed are calculated as opponent's yards
            // This will be handled when we process both teams
        }

        // Calculate rankings (1-32) for all categories
        function calculateRankings() {
            const teams = Object.keys(leagueStats.teams);

            // Initialize rankings object
            teams.forEach(team => {
                leagueStats.rankings[team] = {
                    rushOffRank: 0,
                    passOffRank: 0,
                    rushDefRank: 0,
                    passDefRank: 0
                };
            });

            // Rush offense (higher yards = better rank)
            const rushOffRanked = [...teams].sort((a, b) => leagueStats.teams[b].rushYPG - leagueStats.teams[a].rushYPG);
            rushOffRanked.forEach((team, idx) => leagueStats.rankings[team].rushOffRank = idx + 1);

            // Pass offense (higher yards = better rank)
            const passOffRanked = [...teams].sort((a, b) => leagueStats.teams[b].passYPG - leagueStats.teams[a].passYPG);
            passOffRanked.forEach((team, idx) => leagueStats.rankings[team].passOffRank = idx + 1);

            // Rush defense (lower yards allowed = better rank)
            const rushDefRanked = [...teams].sort((a, b) => leagueStats.teams[a].rushDefYPG - leagueStats.teams[b].rushDefYPG);
            rushDefRanked.forEach((team, idx) => leagueStats.rankings[team].rushDefRank = idx + 1);

            // Pass defense (lower yards allowed = better rank)
            const passDefRanked = [...teams].sort((a, b) => leagueStats.teams[a].passDefYPG - leagueStats.teams[b].passDefYPG);
            passDefRanked.forEach((team, idx) => leagueStats.rankings[team].passDefRank = idx + 1);

            // DEBUG: Log rankings for comparison with ESPN
            console.log('\nüìä CALCULATED RANKINGS (compare with ESPN):');
            console.log('\nüèÉ Rush Offense (YPG):');
            rushOffRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].rushYPG.toFixed(1)} YPG`);
            });
            console.log('\n‚úàÔ∏è Pass Offense (YPG):');
            passOffRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].passYPG.toFixed(1)} YPG`);
            });
            console.log('\nüõ°Ô∏è Rush Defense (YPG Allowed):');
            rushDefRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].rushDefYPG.toFixed(1)} YPG allowed`);
            });
            console.log('\nüö´ Pass Defense (YPG Allowed):');
            passDefRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].passDefYPG.toFixed(1)} YPG allowed`);
            });

            // Show specific team if it's in a game this week
            const dolphins = leagueStats.teams['Miami Dolphins'];
            if (dolphins) {
                console.log('\nüê¨ Miami Dolphins Stats:');
                console.log(`  Rush Off: ${dolphins.rushYPG.toFixed(1)} YPG (Rank #${leagueStats.rankings['Miami Dolphins'].rushOffRank})`);
                console.log(`  Pass Off: ${dolphins.passYPG.toFixed(1)} YPG (Rank #${leagueStats.rankings['Miami Dolphins'].passOffRank})`);
                console.log(`  Rush Def: ${dolphins.rushDefYPG.toFixed(1)} YPG allowed (Rank #${leagueStats.rankings['Miami Dolphins'].rushDefRank})`);
                console.log(`  Pass Def: ${dolphins.passDefYPG.toFixed(1)} YPG allowed (Rank #${leagueStats.rankings['Miami Dolphins'].passDefRank})`);
                console.log(`  Games: ${dolphins.gamesPlayed}`);
            }
        }

        // ===== FETCH INJURIES =====
        async function fetchInjuries() {
            console.log('üè• Fetching injuries from ESPN...');

            try {
                const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/football/nfl/news?limit=100');
                const data = await response.json();

                for (const article of data.articles || []) {
                    if (article.headline.toLowerCase().includes('injury') ||
                        article.headline.toLowerCase().includes('out') ||
                        article.headline.toLowerCase().includes('questionable')) {

                        for (const teamName in TEAM_DATA) {
                            if (article.headline.includes(teamName) ||
                                (article.description && article.description.includes(teamName))) {

                                if (!injuries[teamName]) {
                                    injuries[teamName] = [];
                                }

                                injuries[teamName].push({
                                    headline: article.headline,
                                    link: article.links?.web?.href || '#',
                                    description: article.description || ''
                                });
                            }
                        }
                    }
                }

                console.log(`‚úÖ Found injury reports for ${Object.keys(injuries).length} teams`);
            } catch (error) {
                console.warn('Could not fetch injuries:', error.message);
            }
        }

        // ===== FETCH GAMES =====
        async function fetchGames() {
            console.log('üì• Fetching games from ESPN...');

            const games = [];
            const now = new Date();
            const fiveHoursAgo = new Date(now.getTime() - 5 * 60 * 60 * 1000);
            const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000);

            const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard');
            const data = await response.json();

            let currentWeek = null;
            if (data.week && data.week.number) {
                currentWeek = data.week.number;
                document.getElementById('weekIndicator').textContent = `Week ${currentWeek}`;
            }

            // Filter games: include future games, in-progress, and completed within last hour
            for (const event of data.events || []) {
                const gameDate = new Date(event.date);
                const competition = event.competitions[0];
                const status = competition.status;

                // Include if:
                // - Game hasn't started yet (future)
                // - Game is in progress
                // - Game completed less than 1 hour ago
                if (status.type.name === 'STATUS_SCHEDULED' ||
                    status.type.name === 'STATUS_IN_PROGRESS' ||
                    (status.type.completed && gameDate >= fiveHoursAgo)) {

                    // If completed, check if it's been more than 1 hour
                    if (status.type.completed) {
                        // Estimate completion time as game start + 3.5 hours
                        const estimatedEnd = new Date(gameDate.getTime() + 3.5 * 60 * 60 * 1000);
                        if (now - estimatedEnd > 60 * 60 * 1000) {
                            continue; // Skip games completed more than 1 hour ago
                        }
                    }

                    games.push(event);
                }
            }

            // If no games found in current week, try next week
            if (games.length === 0 && currentWeek && currentWeek < 18) {
                console.log('üì• No active games this week, fetching next week...');
                const nextWeekResponse = await fetch(`https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2025&seasontype=2&week=${currentWeek + 1}`);
                const nextWeekData = await nextWeekResponse.json();

                if (nextWeekData.week && nextWeekData.week.number) {
                    document.getElementById('weekIndicator').textContent = `Week ${nextWeekData.week.number}`;
                }

                for (const event of nextWeekData.events || []) {
                    games.push(event);
                }
            }

            console.log(`‚úÖ Found ${games.length} games to display`);
            return games;
        }

        // ===== FETCH ODDS =====
        async function fetchOdds() {
            if (!apiKey) return [];

            console.log('üí∞ Fetching odds...');
            const response = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_nfl/odds/?apiKey=${apiKey}&regions=us&markets=spreads,totals,h2h`);

            if (!response.ok) {
                throw new Error('Failed to fetch odds');
            }

            const data = await response.json();
            console.log(`‚úÖ Fetched odds for ${data.length} games`);
            return data;
        }

        // ===== FETCH WEATHER =====
        async function fetchWeather(homeTeam, gameDate) {
            const teamInfo = TEAM_DATA[homeTeam];
            if (!teamInfo) return null;

            try {
                const date = new Date(gameDate);
                const dateStr = date.toISOString().split('T')[0];

                const url = `https://api.open-meteo.com/v1/forecast?latitude=${teamInfo.lat}&longitude=${teamInfo.lon}&hourly=temperature_2m,precipitation_probability,windspeed_10m,weathercode&temperature_unit=fahrenheit&windspeed_unit=mph&timezone=America/New_York&start_date=${dateStr}&end_date=${dateStr}`;

                const response = await fetch(url);
                const data = await response.json();

                const hour = date.getHours();
                const temp = data.hourly.temperature_2m[hour] || 70;
                const precip = data.hourly.precipitation_probability[hour] || 0;
                const wind = data.hourly.windspeed_10m[hour] || 0;
                const code = data.hourly.weathercode[hour] || 0;

                let condition = 'Clear';
                let rain = 0;
                let snow = 0;

                if (code >= 71 && code <= 77) { condition = 'Snow'; snow = 1; }
                else if (code >= 61 && code <= 67) { condition = 'Rain'; rain = 0.5; }
                else if (code >= 80 && code <= 99) { condition = 'Heavy Rain'; rain = 1; }
                else if (code >= 45 && code <= 48) condition = 'Fog';

                return {
                    temp: Math.round(temp),
                    precipitation: precip,
                    windSpeed: Math.round(wind),
                    condition,
                    rain,
                    snow
                };
            } catch (error) {
                console.warn('Weather fetch failed:', error.message);
                return null;
            }
        }

        // ===== ANALYZE INJURY IMPACT =====
        function analyzeInjuryImpact(teamName) {
            const teamInjuries = injuries[teamName] || [];
            let impact = { points: 0, notes: [] };

            for (const injury of teamInjuries) {
                const text = (injury.headline + ' ' + injury.description).toLowerCase();

                // QB injuries - huge impact
                if (text.includes('quarterback') || text.includes(' qb ')) {
                    if (text.includes('out') || text.includes('ruled out')) {
                        impact.points -= 8;
                        impact.notes.push('Starting QB out (-8 pts)');
                    } else if (text.includes('questionable') || text.includes('doubtful')) {
                        impact.points -= 4;
                        impact.notes.push('Starting QB questionable (-4 pts)');
                    }
                }

                // RB injuries - big impact
                else if (text.includes('running back') || text.includes(' rb ')) {
                    if (text.includes('out') || text.includes('ruled out')) {
                        impact.points -= 4;
                        impact.notes.push('Key RB out (-4 pts)');
                    } else if (text.includes('questionable')) {
                        impact.points -= 2;
                        impact.notes.push('Key RB questionable (-2 pts)');
                    }
                }

                // WR injuries - significant for passing
                else if (text.includes('wide receiver') || text.includes(' wr ') || text.includes('receiver')) {
                    if (text.includes('out') || text.includes('ruled out')) {
                        impact.points -= 3;
                        impact.notes.push('Key WR out (-3 pts)');
                    } else if (text.includes('questionable')) {
                        impact.points -= 1.5;
                        impact.notes.push('Key WR questionable (-1.5 pts)');
                    }
                }
            }

            return impact;
        }

        // ===== GENERATE PREDICTION (EFFICIENCY RATING METHOD) =====
        function generatePrediction(game, odds, weather) {
            const competition = game.competitions[0];
            const homeComp = competition.competitors.find(c => c.homeAway === 'home');
            const awayComp = competition.competitors.find(c => c.homeAway === 'away');

            const homeTeam = homeComp.team.displayName;
            const awayTeam = awayComp.team.displayName;

            const homeRecord = homeComp.records?.[0]?.summary || '0-0';
            const awayRecord = awayComp.records?.[0]?.summary || '0-0';

            // Check if we have real data for both teams
            const homeStats = leagueStats.teams[homeTeam];
            const awayStats = leagueStats.teams[awayTeam];
            const homeRankings = leagueStats.rankings[homeTeam];
            const awayRankings = leagueStats.rankings[awayTeam];

            // If missing data, return error instead of using fake fallbacks
            if (!homeStats || !awayStats || !homeRankings || !awayRankings) {
                const missingTeams = [];
                if (!homeStats) missingTeams.push(homeTeam);
                if (!awayStats) missingTeams.push(awayTeam);

                return {
                    error: true,
                    homeTeam,
                    awayTeam,
                    homeRecord,
                    awayRecord,
                    message: `Missing data for: ${missingTeams.join(', ')}`,
                    missingTeams,
                    retryable: true
                };
            }

            let prediction = {
                homeTeam,
                awayTeam,
                homeRecord,
                awayRecord,
                vegasSpread: 'N/A',
                vegasTotal: 'N/A',
                vegasHomeScore: null,
                vegasAwayScore: null,
                weather: weather,
                rationale: [],
                edges: [],
                calculations: [],
                deviation: [],
                injuries: {
                    home: injuries[homeTeam] || [],
                    away: injuries[awayTeam] || []
                }
            };

            // Parse Vegas odds (for comparison only, NOT as base)
            if (odds) {
                const spreadsMarket = odds.bookmakers?.[0]?.markets?.find(m => m.key === 'spreads');
                const totalsMarket = odds.bookmakers?.[0]?.markets?.find(m => m.key === 'totals');

                if (spreadsMarket) {
                    const homeSpread = spreadsMarket.outcomes.find(o => o.name === homeTeam);
                    prediction.vegasSpread = homeSpread?.point || 'N/A';
                }
                if (totalsMarket) {
                    prediction.vegasTotal = totalsMarket.outcomes[0]?.point || 'N/A';
                }

                // Calculate Vegas implied scores
                if (prediction.vegasSpread !== 'N/A' && prediction.vegasTotal !== 'N/A') {
                    const spread = parseFloat(prediction.vegasSpread);
                    const total = parseFloat(prediction.vegasTotal);
                    prediction.vegasHomeScore = Math.round((total - spread) / 2);
                    prediction.vegasAwayScore = Math.round((total + spread) / 2);
                }
            }

            // ===== EFFICIENCY RATING FORMULA =====
            // Away projected points = (Away offensive rating + Home defensive rating) / 2
            // Home projected points = (Home offensive rating + Away defensive rating) / 2 + home field advantage

            const baseAwayScore = (awayStats.offensiveRating + homeStats.defensiveRating) / 2;
            const baseHomeScore = (homeStats.offensiveRating + awayStats.defensiveRating) / 2;

            prediction.calculations.push(`üìä Efficiency Rating Formula:`);
            prediction.calculations.push(`${awayTeam} base: (${awayStats.offensiveRating.toFixed(1)} OFF + ${homeStats.defensiveRating.toFixed(1)} DEF allowed) / 2 = ${baseAwayScore.toFixed(1)}`);
            prediction.calculations.push(`${homeTeam} base: (${homeStats.offensiveRating.toFixed(1)} OFF + ${awayStats.defensiveRating.toFixed(1)} DEF allowed) / 2 = ${baseHomeScore.toFixed(1)}`);

            let ourHomeScore = baseHomeScore;
            let ourAwayScore = baseAwayScore;

            // Home field advantage (2.5-3 pts)
            const homeFieldAdv = 2.5;
            ourHomeScore += homeFieldAdv;
            prediction.calculations.push(`Home field advantage: +${homeFieldAdv} pts to ${homeTeam}`);

            // ===== RUSH/PASS MATCHUP ANALYSIS =====
            // Determine weather weights for rush vs pass importance
            let rushWeight = 1.0;
            let passWeight = 1.0;

            if (weather) {
                if (weather.snow) {
                    rushWeight = 2.0;
                    passWeight = 0.4;
                    prediction.calculations.push(`‚õÑ Snow weather: Rush √ó2.0, Pass √ó0.4`);
                } else if (weather.rain > 0.5) {
                    rushWeight = 1.5;
                    passWeight = 0.7;
                    prediction.calculations.push(`üåßÔ∏è Rain: Rush √ó1.5, Pass √ó0.7`);
                }

                if (weather.windSpeed > 20) {
                    passWeight *= 0.5;
                    prediction.calculations.push(`üí® High winds (${weather.windSpeed}mph): Pass √ó0.5`);
                }
            }

            // Home team rush offense vs away team rush defense
            if (leagueStats.hasData && homeRankings.rushOffRank && awayRankings.rushDefRank) {
                const gap = awayRankings.rushDefRank - homeRankings.rushOffRank;
                const rawAdvantage = gap * 0.15; // 0.15 pts per rank difference
                const advantage = rawAdvantage * rushWeight;

                if (Math.abs(gap) > 5) {
                    ourHomeScore += advantage;
                    const favored = gap > 0 ? homeTeam : awayTeam;
                    prediction.calculations.push(`${homeTeam} #${homeRankings.rushOffRank} rush O vs ${awayTeam} #${awayRankings.rushDefRank} rush D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} rush matchup advantage (#${Math.min(homeRankings.rushOffRank, awayRankings.rushDefRank)} vs #${Math.max(homeRankings.rushOffRank, awayRankings.rushDefRank)})`);
                    }
                }
            }

            // Home team pass offense vs away team pass defense
            if (leagueStats.hasData && homeRankings.passOffRank && awayRankings.passDefRank) {
                const gap = awayRankings.passDefRank - homeRankings.passOffRank;
                const rawAdvantage = gap * 0.15;
                const advantage = rawAdvantage * passWeight;

                if (Math.abs(gap) > 5) {
                    ourHomeScore += advantage;
                    const favored = gap > 0 ? homeTeam : awayTeam;
                    prediction.calculations.push(`${homeTeam} #${homeRankings.passOffRank} pass O vs ${awayTeam} #${awayRankings.passDefRank} pass D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} pass matchup advantage (#${Math.min(homeRankings.passOffRank, awayRankings.passDefRank)} vs #${Math.max(homeRankings.passOffRank, awayRankings.passDefRank)})`);
                    }
                }
            }

            // Away team rush offense vs home team rush defense
            if (leagueStats.hasData && awayRankings.rushOffRank && homeRankings.rushDefRank) {
                const gap = homeRankings.rushDefRank - awayRankings.rushOffRank;
                const rawAdvantage = gap * 0.15;
                const advantage = rawAdvantage * rushWeight;

                if (Math.abs(gap) > 5) {
                    ourAwayScore += advantage;
                    const favored = gap > 0 ? awayTeam : homeTeam;
                    prediction.calculations.push(`${awayTeam} #${awayRankings.rushOffRank} rush O vs ${homeTeam} #${homeRankings.rushDefRank} rush D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} rush matchup advantage (#${Math.min(awayRankings.rushOffRank, homeRankings.rushDefRank)} vs #${Math.max(awayRankings.rushOffRank, homeRankings.rushDefRank)})`);
                    }
                }
            }

            // Away team pass offense vs home team pass defense
            if (leagueStats.hasData && awayRankings.passOffRank && homeRankings.passDefRank) {
                const gap = homeRankings.passDefRank - awayRankings.passOffRank;
                const rawAdvantage = gap * 0.15;
                const advantage = rawAdvantage * passWeight;

                if (Math.abs(gap) > 5) {
                    ourAwayScore += advantage;
                    const favored = gap > 0 ? awayTeam : homeTeam;
                    prediction.calculations.push(`${awayTeam} #${awayRankings.passOffRank} pass O vs ${homeTeam} #${homeRankings.passDefRank} pass D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} pass matchup advantage (#${Math.min(awayRankings.passOffRank, homeRankings.passDefRank)} vs #${Math.max(awayRankings.passOffRank, homeRankings.passDefRank)})`);
                    }
                }
            }

            // ===== SITUATIONAL EFFICIENCY ADJUSTMENTS =====
            // Third down efficiency
            if (homeStats.thirdDownPct > 45) {
                ourHomeScore += 1.5;
                prediction.calculations.push(`${homeTeam} 3rd down efficiency (${homeStats.thirdDownPct.toFixed(1)}%): +1.5 pts`);
            } else if (homeStats.thirdDownPct < 35) {
                ourHomeScore -= 1.5;
                prediction.calculations.push(`${homeTeam} poor 3rd down % (${homeStats.thirdDownPct.toFixed(1)}%): -1.5 pts`);
            }

            if (awayStats.thirdDownPct > 45) {
                ourAwayScore += 1.5;
                prediction.calculations.push(`${awayTeam} 3rd down efficiency (${awayStats.thirdDownPct.toFixed(1)}%): +1.5 pts`);
            } else if (awayStats.thirdDownPct < 35) {
                ourAwayScore -= 1.5;
                prediction.calculations.push(`${awayTeam} poor 3rd down % (${awayStats.thirdDownPct.toFixed(1)}%): -1.5 pts`);
            }

            // Red zone efficiency
            if (homeStats.redZonePct > 60) {
                ourHomeScore += 1.5;
                prediction.calculations.push(`${homeTeam} red zone efficiency (${homeStats.redZonePct.toFixed(1)}%): +1.5 pts`);
            } else if (homeStats.redZonePct < 45) {
                ourHomeScore -= 1.5;
                prediction.calculations.push(`${homeTeam} poor red zone % (${homeStats.redZonePct.toFixed(1)}%): -1.5 pts`);
            }

            if (awayStats.redZonePct > 60) {
                ourAwayScore += 1.5;
                prediction.calculations.push(`${awayTeam} red zone efficiency (${awayStats.redZonePct.toFixed(1)}%): +1.5 pts`);
            } else if (awayStats.redZonePct < 45) {
                ourAwayScore -= 1.5;
                prediction.calculations.push(`${awayTeam} poor red zone % (${awayStats.redZonePct.toFixed(1)}%): -1.5 pts`);
            }

            // Sack differential (pass rush vs O-line)
            const homeSackDiff = (awayStats.sacksTakenPG || 0) - (homeStats.sacksAllowedPG || 0);
            const awaySackDiff = (homeStats.sacksTakenPG || 0) - (awayStats.sacksAllowedPG || 0);

            if (homeSackDiff > 1) {
                ourHomeScore += 1;
                prediction.calculations.push(`${homeTeam} pass rush advantage (sack diff +${homeSackDiff.toFixed(1)}): +1 pt`);
            } else if (homeSackDiff < -1) {
                ourHomeScore -= 1;
                prediction.calculations.push(`${awayTeam} O-line advantage (sack diff ${homeSackDiff.toFixed(1)}): -1 pt to ${homeTeam}`);
            }

            if (awaySackDiff > 1) {
                ourAwayScore += 1;
                prediction.calculations.push(`${awayTeam} pass rush advantage (sack diff +${awaySackDiff.toFixed(1)}): +1 pt`);
            } else if (awaySackDiff < -1) {
                ourAwayScore -= 1;
                prediction.calculations.push(`${homeTeam} O-line advantage (sack diff ${awaySackDiff.toFixed(1)}): -1 pt to ${awayTeam}`);
            }

            // Turnover differential (use cautiously - high variance)
            if (homeStats.turnoverDiff > 8) {
                ourHomeScore += 0.5;
                prediction.calculations.push(`${homeTeam} strong turnover diff (+${homeStats.turnoverDiff}): +0.5 pts`);
            } else if (homeStats.turnoverDiff < -8) {
                ourHomeScore -= 0.5;
                prediction.calculations.push(`${homeTeam} poor turnover diff (${homeStats.turnoverDiff}): -0.5 pts`);
            }

            if (awayStats.turnoverDiff > 8) {
                ourAwayScore += 0.5;
                prediction.calculations.push(`${awayTeam} strong turnover diff (+${awayStats.turnoverDiff}): +0.5 pts`);
            } else if (awayStats.turnoverDiff < -8) {
                ourAwayScore -= 0.5;
                prediction.calculations.push(`${awayTeam} poor turnover diff (${awayStats.turnoverDiff}): -0.5 pts`);
            }

            // ===== WEATHER SCORING REDUCTION =====
            if (weather) {
                if (weather.snow || weather.rain > 0.5 || weather.windSpeed > 20) {
                    let weatherImpact = 0;

                    if (weather.snow) {
                        weatherImpact = -4; // Heavy snow reduces scoring
                        prediction.calculations.push(`${weather.condition}: -4 pts total scoring (favors defense)`);
                    } else if (weather.rain > 0.5) {
                        weatherImpact = -2;
                        prediction.calculations.push(`${weather.condition}: -2 pts total scoring`);
                    }

                    if (weather.windSpeed > 20) {
                        weatherImpact -= 2;
                        prediction.calculations.push(`High winds (${weather.windSpeed}mph): -2 pts scoring`);
                    }

                    // Split weather impact between both teams
                    ourHomeScore += weatherImpact / 2;
                    ourAwayScore += weatherImpact / 2;
                }
            }

            // ===== INJURY IMPACT =====
            const homeInjuryImpact = analyzeInjuryImpact(homeTeam);
            const awayInjuryImpact = analyzeInjuryImpact(awayTeam);

            if (homeInjuryImpact.points !== 0) {
                ourHomeScore += homeInjuryImpact.points;
                homeInjuryImpact.notes.forEach(note => prediction.calculations.push(`${homeTeam}: ${note}`));
            }

            if (awayInjuryImpact.points !== 0) {
                ourAwayScore += awayInjuryImpact.points;
                awayInjuryImpact.notes.forEach(note => prediction.calculations.push(`${awayTeam}: ${note}`));
            }

            // Finalize our prediction
            prediction.homeScore = Math.max(10, Math.round(ourHomeScore));
            prediction.awayScore = Math.max(10, Math.round(ourAwayScore));

            if (prediction.homeScore === prediction.awayScore) {
                prediction.homeScore += 1;
                prediction.calculations.push(`Tie-breaker: +1 to ${homeTeam}`);
            }

            prediction.winner = prediction.homeScore > prediction.awayScore ? homeTeam : awayTeam;
            const margin = Math.abs(prediction.homeScore - prediction.awayScore);

            // ===== DEVIATION ANALYSIS (Compare to Vegas) =====
            if (prediction.vegasHomeScore && prediction.vegasAwayScore) {
                const scoreDiff = (prediction.homeScore - prediction.awayScore) - (prediction.vegasHomeScore - prediction.vegasAwayScore);
                const totalDiff = (prediction.homeScore + prediction.awayScore) - (prediction.vegasHomeScore + prediction.vegasAwayScore);

                prediction.deviation.push(`BRObet: ${homeTeam} ${prediction.homeScore}, ${awayTeam} ${prediction.awayScore}`);
                prediction.deviation.push(`Vegas: ${homeTeam} ${prediction.vegasHomeScore}, ${awayTeam} ${prediction.vegasAwayScore}`);

                if (Math.abs(scoreDiff) > 3) {
                    const favorsTeam = scoreDiff > 0 ? homeTeam : awayTeam;
                    prediction.deviation.push(`üî• BRObet favors ${favorsTeam} ${Math.abs(scoreDiff).toFixed(1)} pts more than Vegas`);
                    prediction.rationale.push(`Significant deviation from Vegas (${Math.abs(scoreDiff).toFixed(1)} pt spread difference)`);
                } else {
                    prediction.deviation.push(`‚úì Close agreement with Vegas (${Math.abs(scoreDiff).toFixed(1)} pt spread difference)`);
                }

                if (Math.abs(totalDiff) > 6) {
                    const direction = totalDiff > 0 ? 'OVER' : 'UNDER';
                    prediction.deviation.push(`üìä ${direction} Vegas total by ${Math.abs(totalDiff).toFixed(1)} pts`);
                }
            }

            // Build rationale
            prediction.rationale.push(`${prediction.winner} by ${margin} points`);

            if (prediction.vegasSpread !== 'N/A') {
                const vegasFav = parseFloat(prediction.vegasSpread) < 0 ? homeTeam : awayTeam;
                prediction.rationale.push(`Vegas favors: ${vegasFav} by ${Math.abs(parseFloat(prediction.vegasSpread))} pts`);
            }

            // Add efficiency context to rationale
            const winnerStats = prediction.winner === homeTeam ? homeStats : awayStats;
            prediction.rationale.push(`${prediction.winner} averages ${winnerStats.offensiveRating.toFixed(1)} ppg`);

            // Confidence based on prediction margin and edge count
            let confidenceScore = margin;
            if (prediction.edges.length >= 2) confidenceScore += 5;
            if (prediction.edges.length >= 3) confidenceScore += 3;

            if (confidenceScore >= 14) prediction.confidence = 'High';
            else if (confidenceScore >= 8) prediction.confidence = 'Medium';
            else prediction.confidence = 'Low';

            return prediction;
        }

        // ===== DISPLAY GAMES =====
        async function displayGames(games, oddsData) {
            const gamesContainer = document.getElementById('games');
            const picksList = document.getElementById('picks-list');
            const picksSummary = document.getElementById('picksummary');

            gamesContainer.innerHTML = '';
            picksList.innerHTML = '';

            if (games.length === 0) {
                gamesContainer.innerHTML = '<div style="text-align: center; padding: 3rem;">No upcoming games</div>';
                return;
            }

            const gamesWithPredictions = [];

            for (const game of games) {
                const competition = game.competitions[0];
                const homeComp = competition.competitors.find(c => c.homeAway === 'home');
                const homeTeam = homeComp.team.displayName;

                const gameOdds = oddsData.find(o =>
                    o.home_team === homeTeam ||
                    (o.home_team.includes(homeTeam.split(' ').pop()) && o.commence_time &&
                     Math.abs(new Date(o.commence_time) - new Date(game.date)) < 3600000)
                );

                const weather = await fetchWeather(homeTeam, game.date);
                const prediction = generatePrediction(game, gameOdds, weather);

                const gameId = game.id;

                // Only save valid predictions (not errors)
                if (!prediction.error) {
                    savePrediction(gameId, game.date, prediction);
                }

                gamesWithPredictions.push({ game, prediction, gameId });
            }

            const confidenceOrder = { 'High': 0, 'Medium': 1, 'Low': 2 };
            gamesWithPredictions.sort((a, b) => {
                const dateA = new Date(a.game.date);
                const dateB = new Date(b.game.date);
                if (dateA.toDateString() !== dateB.toDateString()) {
                    return dateA - dateB;
                }
                // Show errors last, then sort by confidence
                if (a.prediction.error && !b.prediction.error) return 1;
                if (!a.prediction.error && b.prediction.error) return -1;
                if (a.prediction.error && b.prediction.error) return 0;
                return confidenceOrder[a.prediction.confidence] - confidenceOrder[b.prediction.confidence];
            });

            gamesWithPredictions.forEach(({ prediction, gameId }) => {
                // Skip error predictions in picks summary
                if (prediction.error) return;
                const teamColor = TEAM_DATA[prediction.winner]?.color || '#3498db';
                const loser = prediction.winner === prediction.homeTeam ? prediction.awayTeam : prediction.homeTeam;

                picksList.innerHTML += `
                    <div onclick="document.getElementById('${gameId}').scrollIntoView({behavior: 'smooth', block: 'center'})"
                         style="background: rgba(255,255,255,0.05); padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; border-left: 4px solid ${teamColor}; transition: all 0.2s;"
                         onmouseover="this.style.background='rgba(255,255,255,0.1)'"
                         onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                        <div style="font-weight: bold; font-size: 1.1rem;">${prediction.winner}</div>
                        <div style="font-size: 0.85rem; opacity: 0.9;">over ${loser}</div>
                        <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">
                            ${prediction.homeScore}-${prediction.awayScore} ‚Ä¢ ${prediction.confidence}
                        </div>
                    </div>
                `;
            });
            picksSummary.style.display = 'block';

            gamesWithPredictions.forEach(({ game, prediction, gameId }) => {
                gamesContainer.innerHTML += createGameCard(game, prediction, gameId);
            });

            // Populate Week Results section with completed games
            await populateWeekResults(games);
        }

        // ===== WEEK RESULTS SECTION =====
        async function populateWeekResults(games) {
            const weekResultsContainer = document.getElementById('weekresults');
            const weekResultsList = document.getElementById('weekresults-list');
            const weekResultsTitle = document.getElementById('weekresults-title');

            // Filter for completed games only
            const completedGames = games.filter(game => {
                const competition = game.competitions[0];
                return competition.status.type.completed;
            });

            if (completedGames.length === 0) {
                weekResultsContainer.style.display = 'none';
                return;
            }

            let correct = 0;
            let total = 0;
            weekResultsList.innerHTML = '';

            for (const game of completedGames) {
                const competition = game.competitions[0];
                const homeComp = competition.competitors.find(c => c.homeAway === 'home');
                const awayComp = competition.competitors.find(c => c.homeAway === 'away');
                const homeTeam = homeComp.team.displayName;
                const awayTeam = awayComp.team.displayName;
                const actualHomeScore = parseInt(homeComp.score) || 0;
                const actualAwayScore = parseInt(awayComp.score) || 0;
                const actualWinner = actualHomeScore > actualAwayScore ? homeTeam : awayTeam;

                // Get our prediction from localStorage or generate one
                const savedPrediction = predictions[game.id];
                let predictedWinner = null;

                if (savedPrediction && savedPrediction.prediction) {
                    predictedWinner = savedPrediction.prediction.winner;
                } else {
                    // Try to infer from current prediction logic
                    continue; // Skip if no saved prediction
                }

                const isCorrect = predictedWinner === actualWinner;
                if (isCorrect) correct++;
                total++;

                const resultClass = isCorrect ? 'correct' : 'incorrect';
                const resultIcon = isCorrect ? '‚úì' : '‚úó';

                weekResultsList.innerHTML += `
                    <div class="result-item ${resultClass}" onclick="document.getElementById('${game.id}').scrollIntoView({behavior: 'smooth', block: 'center'})">
                        <div class="result-icon ${resultClass}">${resultIcon}</div>
                        <div class="result-teams">
                            <div style="font-weight: bold;">${predictedWinner}</div>
                            <div class="result-score">Predicted: ${predictedWinner} ‚Ä¢ Actual: ${actualWinner} (${actualAwayScore}-${actualHomeScore})</div>
                        </div>
                    </div>
                `;
            }

            const percentage = total > 0 ? ((correct / total) * 100).toFixed(0) : 0;
            weekResultsTitle.textContent = `üìä Week Results: ${correct}-${total - correct} (${percentage}%)`;
            weekResultsContainer.style.display = 'block';
        }

        function toggleWeekResults() {
            const content = document.getElementById('weekresults-content');
            const toggle = document.getElementById('weekresults-toggle');

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }

        function createGameCard(game, prediction, gameId) {
            // Handle error predictions
            if (prediction.error) {
                const homeLogo = TEAM_DATA[prediction.homeTeam]?.logo;
                const awayLogo = TEAM_DATA[prediction.awayTeam]?.logo;
                const gameDate = new Date(game.date);
                const gameTime = gameDate.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });

                return `
                    <div id="${gameId}" class="game-card" style="background: linear-gradient(135deg, #e74c3c22 0%, #e74c3c44 100%); border: 2px solid #e74c3c88;">
                        <div class="game-header" style="background-color: #e74c3c; text-align: center;">
                            <div class="game-meta">
                                <div class="badge">üìÖ ${gameTime}</div>
                                <div class="badge" style="background: #c0392b;">‚ö†Ô∏è DATA ERROR</div>
                            </div>
                            <div class="teams">
                                <div class="team">
                                    ${awayLogo ? `<img src="${awayLogo}" alt="${prediction.awayTeam}" class="team-logo">` : ''}
                                    <div>
                                        <div class="team-name">${prediction.awayTeam}</div>
                                        <div class="team-record">${prediction.awayRecord}</div>
                                    </div>
                                </div>
                                <div style="font-size: 1.5rem; color: white;">@</div>
                                <div class="team">
                                    ${homeLogo ? `<img src="${homeLogo}" alt="${prediction.homeTeam}" class="team-logo">` : ''}
                                    <div>
                                        <div class="team-name">${prediction.homeTeam}</div>
                                        <div class="team-record">${prediction.homeRecord}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="padding: 2rem; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #e74c3c; margin-bottom: 1rem;">‚ö†Ô∏è Unable to Generate Prediction</div>
                            <div style="color: #999; margin-bottom: 1rem;">${prediction.message}</div>
                            <div style="color: #666; font-size: 0.9rem; margin-bottom: 1.5rem;">
                                Real team data is required for accurate predictions. Using fallback averages would produce misleading results.
                            </div>
                            <button onclick="location.reload()" style="background: #3498db; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-size: 1rem; font-weight: bold;">
                                üîÑ Retry Now
                            </button>
                            <div id="retry-timer-${gameId}" style="color: #999; font-size: 0.9rem; margin-top: 1rem;">
                                Auto-retry in <span id="countdown-${gameId}">15:00</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            const teamColor = TEAM_DATA[prediction.homeTeam]?.color || '#3498db';
            const homeLogo = TEAM_DATA[prediction.homeTeam]?.logo;
            const awayLogo = TEAM_DATA[prediction.awayTeam]?.logo;

            const gameDate = new Date(game.date);
            const gameTime = gameDate.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            });

            const confidenceClass = `confidence-${prediction.confidence.toLowerCase()}`;

            // Get game status from ESPN data
            const competition = game.competitions[0];
            const status = competition.status;
            const isLive = status.type.name === 'STATUS_IN_PROGRESS';
            const isCompleted = status.type.completed;
            const homeComp = competition.competitors.find(c => c.homeAway === 'home');
            const awayComp = competition.competitors.find(c => c.homeAway === 'away');
            const actualHomeScore = parseInt(homeComp.score) || 0;
            const actualAwayScore = parseInt(awayComp.score) || 0;
            const actualWinner = actualHomeScore > actualAwayScore ? prediction.homeTeam : prediction.awayTeam;
            const predictionCorrect = isCompleted && (actualWinner === prediction.winner);

            // Game status badge (LIVE or game state)
            let statusBadgeHTML = '';
            if (isLive) {
                const period = status.period || 1;
                const clock = status.displayClock || '';
                const periodText = period <= 4 ? `Q${period}` : (period === 5 ? 'OT' : `OT${period-4}`);
                statusBadgeHTML = `<div class="badge live-badge">üî¥ LIVE ‚Ä¢ ${periodText} ${clock}</div>`;
            }

            // Result badge (WINNER/LOSER)
            let resultBadgeHTML = '';
            if (isCompleted) {
                if (predictionCorrect) {
                    resultBadgeHTML = `<div class="result-winner">‚úÖ WINNER!</div>`;
                } else {
                    resultBadgeHTML = `<div class="result-loser">‚ùå LOSER</div>`;
                }
            }

            // Live scores HTML
            let liveScoresHTML = '';
            if (isLive || isCompleted) {
                const homeWinning = actualHomeScore > actualAwayScore;
                const awayWinning = actualAwayScore > actualHomeScore;
                liveScoresHTML = `
                    <div class="live-scores">
                        <div class="live-score-row ${awayWinning ? 'winning' : ''}">
                            <span>${prediction.awayTeam}</span>
                            <span>${actualAwayScore}</span>
                        </div>
                        <div class="live-score-row ${homeWinning ? 'winning' : ''}">
                            <span>${prediction.homeTeam}</span>
                            <span>${actualHomeScore}</span>
                        </div>
                        ${isLive ? `<div class="game-status">${status.type.shortDetail || 'In Progress'}</div>` : ''}
                        ${isCompleted ? `<div class="game-status">Final</div>` : ''}
                    </div>
                `;
            }

            // Detect upset (underdog favored): team with worse record is predicted to win
            let isUpset = false;
            const homeWins = parseInt(prediction.homeRecord.split('-')[0]) || 0;
            const awayWins = parseInt(prediction.awayRecord.split('-')[0]) || 0;
            if ((prediction.winner === prediction.homeTeam && awayWins > homeWins + 2) ||
                (prediction.winner === prediction.awayTeam && homeWins > awayWins + 2)) {
                isUpset = true;
            }

            let upsetHTML = isUpset ? '<div class="badge upset-alert">üî• UPSET ALERT</div>' : '';

            let weatherHTML = '';
            if (prediction.weather) {
                const w = prediction.weather;
                let weatherIcon = '‚òÄÔ∏è';
                if (w.condition === 'Snow') weatherIcon = '‚ùÑÔ∏è';
                else if (w.condition.includes('Rain')) weatherIcon = 'üåßÔ∏è';
                else if (w.condition === 'Fog') weatherIcon = 'üå´Ô∏è';

                weatherHTML = `<div class="badge" style="background: rgba(255,255,255,0.2);">${weatherIcon} ${w.temp}¬∞F ${w.condition}${w.windSpeed > 15 ? ` ‚Ä¢ ${w.windSpeed}mph` : ''}</div>`;
            }

            // Removed fallback badge - using reliable hardcoded rankings

            let rationaleHTML = '';
            if (prediction.rationale.length > 0) {
                rationaleHTML = '<div class="rationale"><strong>Summary:</strong>';
                prediction.rationale.forEach(reason => {
                    rationaleHTML += `<div class="rationale-item">‚Ä¢ ${reason}</div>`;
                });
                rationaleHTML += '</div>';
            }

            let calculationsHTML = '';
            if (prediction.calculations.length > 0) {
                calculationsHTML = '<div class="rationale" style="margin-top: 1rem;"><strong>How We Calculated This:</strong>';
                prediction.calculations.forEach(calc => {
                    calculationsHTML += `<div class="rationale-item">‚Üí ${calc}</div>`;
                });
                calculationsHTML += '</div>';
            }

            let deviationHTML = '';
            if (prediction.deviation && prediction.deviation.length > 0) {
                deviationHTML = '<div class="rationale" style="margin-top: 1rem; background: rgba(52, 152, 219, 0.15);"><strong>üìä Deviation from Vegas:</strong>';
                prediction.deviation.forEach(dev => {
                    deviationHTML += `<div class="rationale-item">‚Üí ${dev}</div>`;
                });
                deviationHTML += '</div>';
            }

            let edgesHTML = '';
            if (prediction.edges.length > 0) {
                edgesHTML = '<div class="prediction-section"><div class="prediction-title">‚ö° Key Matchup Edges</div>';
                prediction.edges.forEach(edge => {
                    edgesHTML += `<div class="matchup-edge"><div class="edge-item">üî• ${edge}</div></div>`;
                });
                edgesHTML += '</div>';
            }

            let injuryHTML = '';
            if (prediction.injuries.home.length > 0 || prediction.injuries.away.length > 0) {
                injuryHTML = '<div class="prediction-section"><div class="prediction-title">üè• Key Injuries</div>';
                if (prediction.injuries.home.length > 0) {
                    injuryHTML += `<div class="injuries"><strong>${prediction.homeTeam}:</strong>`;
                    prediction.injuries.home.slice(0, 3).forEach(inj => {
                        const truncated = inj.headline.substring(0, 80) + (inj.headline.length > 80 ? '...' : '');
                        injuryHTML += `<div class="injury-item">‚Ä¢ <a href="${inj.link}" target="_blank" rel="noopener noreferrer">${truncated}</a></div>`;
                    });
                    injuryHTML += '</div>';
                }
                if (prediction.injuries.away.length > 0) {
                    injuryHTML += `<div class="injuries"><strong>${prediction.awayTeam}:</strong>`;
                    prediction.injuries.away.slice(0, 3).forEach(inj => {
                        const truncated = inj.headline.substring(0, 80) + (inj.headline.length > 80 ? '...' : '');
                        injuryHTML += `<div class="injury-item">‚Ä¢ <a href="${inj.link}" target="_blank" rel="noopener noreferrer">${truncated}</a></div>`;
                    });
                    injuryHTML += '</div>';
                }
                injuryHTML += '</div>';
            }

            return `
                <div id="${gameId}" class="game-card" style="background: linear-gradient(135deg, ${teamColor}22 0%, ${teamColor}44 100%); border: 2px solid ${teamColor}88;">
                    <div class="game-header" style="background-color: ${teamColor}ee;">
                        <div class="game-meta">
                            <div class="badge">üìÖ ${gameTime}</div>
                            ${statusBadgeHTML}
                            ${upsetHTML}
                            ${weatherHTML}
                            <div class="badge ${confidenceClass}">${prediction.confidence.toUpperCase()}</div>
                        </div>
                        <div class="teams">
                            <div class="team">
                                ${awayLogo ? `<img src="${awayLogo}" alt="${prediction.awayTeam}" class="team-logo">` : ''}
                                <div>
                                    <div class="team-name"
                                         onmouseover="showEloChart('${prediction.awayTeam}', event)"
                                         onmouseout="hideEloChart()"
                                         onclick="event.stopPropagation(); toggleEloChartSticky('${prediction.awayTeam}', event)">
                                        ${prediction.awayTeam}
                                    </div>
                                    <div class="team-record">${prediction.awayRecord}</div>
                                    ${teamAccuracy[prediction.awayTeam] && teamAccuracy[prediction.awayTeam].total > 0 ? `
                                        <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">
                                            ${teamAccuracy[prediction.awayTeam].correct}-${teamAccuracy[prediction.awayTeam].total - teamAccuracy[prediction.awayTeam].correct}
                                            (${((teamAccuracy[prediction.awayTeam].correct / teamAccuracy[prediction.awayTeam].total) * 100).toFixed(0)}%)
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="vs">@</div>
                            <div class="team">
                                <div style="text-align: right;">
                                    <div class="team-name"
                                         onmouseover="showEloChart('${prediction.homeTeam}', event)"
                                         onmouseout="hideEloChart()"
                                         onclick="event.stopPropagation(); toggleEloChartSticky('${prediction.homeTeam}', event)">
                                        ${prediction.homeTeam}
                                    </div>
                                    <div class="team-record">${prediction.homeRecord}</div>
                                    ${teamAccuracy[prediction.homeTeam] && teamAccuracy[prediction.homeTeam].total > 0 ? `
                                        <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">
                                            ${teamAccuracy[prediction.homeTeam].correct}-${teamAccuracy[prediction.homeTeam].total - teamAccuracy[prediction.homeTeam].correct}
                                            (${((teamAccuracy[prediction.homeTeam].correct / teamAccuracy[prediction.homeTeam].total) * 100).toFixed(0)}%)
                                        </div>
                                    ` : ''}
                                </div>
                                ${homeLogo ? `<img src="${homeLogo}" alt="${prediction.homeTeam}" class="team-logo">` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="game-body" onclick="showGameDetails('${gameId}')">
                        ${resultBadgeHTML ? `<div style="text-align: center; margin-bottom: 1.5rem;">${resultBadgeHTML}</div>` : ''}

                        ${liveScoresHTML}

                        <div class="winner-section">
                            <div class="winner-label">üéØ OUR PREDICTION</div>
                            <div class="winner-name">${prediction.winner}</div>
                            <div class="confidence">Confidence: ${prediction.confidence}</div>
                            ${rationaleHTML}
                            ${deviationHTML}
                            ${calculationsHTML}
                        </div>

                        ${edgesHTML}
                        ${injuryHTML}

                        <div class="prediction-section">
                            <div class="prediction-title">üìä Score Predictions</div>
                            <div class="prediction-grid">
                                <div class="pred-stat">
                                    <div class="pred-label">üèà BRObet</div>
                                    <div class="pred-value" style="font-size: 1.5rem;">${prediction.homeScore} - ${prediction.awayScore}</div>
                                </div>
                                ${prediction.vegasHomeScore ? `
                                <div class="pred-stat">
                                    <div class="pred-label">üí∞ Vegas</div>
                                    <div class="pred-value" style="font-size: 1.5rem; color: #f39c12;">${prediction.vegasHomeScore} - ${prediction.vegasAwayScore}</div>
                                </div>
                                ` : ''}
                            </div>
                        </div>

                        ${prediction.vegasSpread !== 'N/A' ? `
                        <div class="prediction-section">
                            <div class="prediction-title">üí∞ Vegas Betting Lines</div>
                            <div class="stats-breakdown">
                                <div class="stat-row">
                                    <span>Spread:</span>
                                    <strong>${prediction.homeTeam} ${prediction.vegasSpread}</strong>
                                </div>
                                <div class="stat-row">
                                    <span>Over/Under:</span>
                                    <strong>${prediction.vegasTotal}</strong>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function savePrediction(gameId, gameDate, prediction) {
            const gameTime = new Date(gameDate);
            const now = new Date();

            if (now < gameTime) {
                predictions[gameId] = {
                    date: gameDate,
                    prediction: {
                        winner: prediction.winner,
                        homeTeam: prediction.homeTeam,
                        awayTeam: prediction.awayTeam,
                        homeScore: prediction.homeScore,
                        awayScore: prediction.awayScore
                    }
                };
                localStorage.setItem('nfl_predictions', JSON.stringify(predictions));
            }
        }

        // Note: Prediction checking is now handled by GitHub Actions
        // which updates results.json automatically

        // ===== ELO CHART DISPLAY =====
        let currentEloChart = null;
        let eloChartSticky = false;

        function showEloChart(teamName, event) {
            if (!weeklyEloData || !weeklyEloData.snapshots) return;

            const chart = document.getElementById('eloChart');
            const teamData = [];
            const weeks = [];

            // Collect Elo ratings for this team across all weeks
            for (let week = 1; week <= weeklyEloData.weeks; week++) {
                const snapshot = weeklyEloData.snapshots[`week${week}`];
                if (snapshot && snapshot[teamName]) {
                    teamData.push(snapshot[teamName]);
                    weeks.push(week);
                }
            }

            if (teamData.length === 0) return;

            const currentElo = teamData[teamData.length - 1];
            const startElo = teamData[0];
            const change = currentElo - startElo;
            const changeSymbol = change >= 0 ? '‚Üë' : '‚Üì';
            const changeColor = change >= 0 ? '#27ae60' : '#e74c3c';

            // Create simple ASCII-style chart
            const max = Math.max(...teamData);
            const min = Math.min(...teamData);
            const range = max - min;

            let chartHTML = `
                <div class="elo-chart-header">${teamName}</div>
                <div class="elo-current">${currentElo}</div>
                <div style="text-align: center; color: ${changeColor}; margin-bottom: 0.5rem;">
                    ${changeSymbol} ${Math.abs(change)} from Week 1
                </div>
                <div class="elo-chart-canvas">
                    <canvas id="eloCanvas" width="350" height="150"></canvas>
                </div>
                <div style="font-size: 0.85rem; opacity: 0.8; text-align: center;">
                    Week 1: ${startElo} ‚Ä¢ Week ${weeks[weeks.length-1]}: ${currentElo}
                </div>
            `;

            chart.innerHTML = chartHTML;
            chart.className = 'elo-chart show';

            // Position near the team name
            const rect = event.target.getBoundingClientRect();
            chart.style.left = Math.min(rect.left, window.innerWidth - 420) + 'px';
            chart.style.top = (rect.bottom + 10) + 'px';

            // Draw chart on canvas
            setTimeout(() => {
                const canvas = document.getElementById('eloCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 350, 150);

                // Draw line
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();

                teamData.forEach((elo, i) => {
                    const x = (i / (teamData.length - 1)) * 330 + 10;
                    const y = 140 - ((elo - min) / (range || 1)) * 120;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Draw points
                ctx.fillStyle = '#3498db';
                teamData.forEach((elo, i) => {
                    const x = (i / (teamData.length - 1)) * 330 + 10;
                    const y = 140 - ((elo - min) / (range || 1)) * 120;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }, 100);

            currentEloChart = teamName;
        }

        function hideEloChart() {
            if (eloChartSticky) return;
            const chart = document.getElementById('eloChart');
            chart.className = 'elo-chart';
            currentEloChart = null;
        }

        function toggleEloChartSticky(teamName, event) {
            event.stopPropagation();
            if (currentEloChart === teamName && eloChartSticky) {
                eloChartSticky = false;
                hideEloChart();
            } else {
                eloChartSticky = true;
                showEloChart(teamName, event);
                document.getElementById('eloChart').classList.add('sticky');
            }
        }

        // Close sticky chart when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (eloChartSticky && !e.target.closest('.elo-chart') && !e.target.closest('.team-name')) {
                eloChartSticky = false;
                hideEloChart();
            }
        });

        // ===== GAME DETAILS MODAL =====
        async function showGameDetails(gameId) {
            try {
                const response = await fetch('test-results.json');
                if (!response.ok) return;

                const data = await response.json();
                const game = data.games.find(g => g.gameId === gameId);
                if (!game) return;

                const modal = document.getElementById('gameModal');
                const modalBody = document.getElementById('modalBody');

                const correctSymbol = game.correct ? '‚úÖ' : '‚ùå';
                const resultColor = game.correct ? '#27ae60' : '#e74c3c';

                modalBody.innerHTML = `
                    <div class="modal-title">${game.awayTeam} @ ${game.homeTeam}</div>

                    <div class="modal-section" style="border-left: 4px solid ${resultColor};">
                        <div class="modal-section-title">${correctSymbol} Prediction Result</div>
                        <div style="font-size: 1.2rem; margin: 0.5rem 0;">
                            <strong>Predicted:</strong> ${game.winner} (${game.awayScore}-${game.homeScore})
                        </div>
                        <div style="font-size: 1.2rem; margin: 0.5rem 0;">
                            <strong>Actual:</strong> ${game.actualWinner} (${game.actualAwayScore}-${game.actualHomeScore})
                        </div>
                        <div style="margin-top: 0.5rem; opacity: 0.9;">
                            ${game.correct ? '‚úì Correctly predicted the winner' : '‚úó Incorrect prediction'}
                        </div>
                    </div>

                    <div class="modal-section">
                        <div class="modal-section-title">üìä Score Analysis</div>
                        <div style="margin: 0.5rem 0;">
                            <strong>${game.homeTeam}:</strong> Predicted ${game.homeScore}, Actual ${game.actualHomeScore}
                            (${game.homeScore > game.actualHomeScore ? 'over' : 'under'} by ${Math.abs(game.homeScore - game.actualHomeScore)})
                        </div>
                        <div style="margin: 0.5rem 0;">
                            <strong>${game.awayTeam}:</strong> Predicted ${game.awayScore}, Actual ${game.actualAwayScore}
                            (${game.awayScore > game.actualAwayScore ? 'over' : 'under'} by ${Math.abs(game.awayScore - game.actualAwayScore)})
                        </div>
                        <div style="margin-top: 0.5rem; opacity: 0.9;">
                            Total predicted: ${game.homeScore + game.awayScore} ‚Ä¢ Actual: ${game.actualHomeScore + game.actualAwayScore}
                        </div>
                    </div>

                    ${game.week ? `<div class="modal-section">
                        <div class="modal-section-title">üìÖ Game Info</div>
                        <div>Week ${game.week}</div>
                        <div>${new Date(game.date).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}</div>
                    </div>` : ''}
                `;

                modal.classList.add('show');
            } catch (error) {
                console.error('Error loading game details:', error);
            }
        }

        function closeModal() {
            document.getElementById('gameModal').classList.remove('show');
        }

        // Close modal on outside click
        document.getElementById('gameModal').addEventListener('click', (e) => {
            if (e.target.id === 'gameModal') closeModal();
        });

        // ===== AUTO-REFRESH FOR LIVE GAMES =====
        let refreshInterval = null;

        function startAutoRefresh() {
            // Refresh every 2.5 minutes (150 seconds)
            refreshInterval = setInterval(async () => {
                console.log('üîÑ Auto-refreshing game data...');
                try {
                    // Fetch latest game data
                    const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard');
                    const data = await response.json();

                    // Update each game card with latest data
                    for (const event of data.events || []) {
                        const gameCard = document.getElementById(event.id);
                        if (!gameCard) continue;

                        const competition = event.competitions[0];
                        const status = competition.status;

                        // Check if any games are live
                        if (status.type.name === 'STATUS_IN_PROGRESS') {
                            // Reload the entire page to update all games
                            console.log('üì∫ Live game detected, reloading page...');
                            location.reload();
                            return;
                        }

                        // Check if any completed games passed the 1-hour mark
                        if (status.type.completed) {
                            const gameDate = new Date(event.date);
                            const estimatedEnd = new Date(gameDate.getTime() + 3.5 * 60 * 60 * 1000);
                            const now = new Date();
                            if (now - estimatedEnd > 60 * 60 * 1000) {
                                // Game completed over an hour ago, reload to remove it
                                console.log('üóëÔ∏è Old game detected, reloading page...');
                                location.reload();
                                return;
                            }
                        }
                    }

                    console.log('‚úÖ No updates needed');
                } catch (error) {
                    console.error('Error during auto-refresh:', error);
                }
            }, 150000); // 150 seconds = 2.5 minutes

            console.log('‚úÖ Auto-refresh enabled (every 2.5 minutes)');
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
                console.log('‚è∏Ô∏è Auto-refresh disabled');
            }
        }

        // ===== AUTO-RETRY FOR FAILED PREDICTIONS =====
        function startRetryCountdown() {
            const errorCards = document.querySelectorAll('[id^="retry-timer-"]');
            if (errorCards.length === 0) return;

            let timeLeft = 15 * 60; // 15 minutes in seconds

            const interval = setInterval(() => {
                timeLeft--;

                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                errorCards.forEach(card => {
                    const countdownSpan = card.querySelector('[id^="countdown-"]');
                    if (countdownSpan) {
                        countdownSpan.textContent = display;
                    }
                });

                if (timeLeft <= 0) {
                    clearInterval(interval);
                    console.log('üîÑ Auto-retrying to fetch missing data...');
                    location.reload();
                }
            }, 1000);
        }

        // Start countdown if there are error cards
        setTimeout(startRetryCountdown, 1000);
    </script>
</body>
</html>
