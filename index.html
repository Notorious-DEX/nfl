<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRObet - NFL Predictions (Beta)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 1rem;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 0.5rem;
            color: #3498db;
            font-weight: 900;
        }

        .tagline {
            color: #95a5a6;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            font-weight: 500;
        }

        .week-indicator {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #3498db;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .api-setup {
            background: rgba(52, 152, 219, 0.1);
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .api-setup h3 {
            margin-bottom: 1rem;
            color: #3498db;
        }

        .api-setup input {
            width: 100%;
            max-width: 400px;
            padding: 0.75rem;
            margin: 1rem 0;
            border-radius: 0.5rem;
            border: 2px solid rgba(52, 152, 219, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 1rem;
        }

        .api-setup button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .api-setup button:hover {
            transform: scale(1.05);
        }

        .scoreboard {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }

        .scoreboard-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .stats {
            display: flex;
            gap: 2rem;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            color: #95a5a6;
            margin-top: 0.25rem;
            font-size: 0.9rem;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            font-size: 1.2rem;
            color: #3498db;
        }

        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid rgba(231, 76, 60, 0.5);
            color: #e74c3c;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 500px), 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .game-card {
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .game-card:hover {
            transform: translateY(-5px);
        }

        .game-header {
            padding: 1.5rem;
            color: white;
        }

        .game-meta {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .confidence-high {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .confidence-low {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .fallback-badge {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
        }

        .teams {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 1rem;
        }

        .team {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .team-logo {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .team-name {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .team-record {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .vs {
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 0.5;
        }

        .game-body {
            background: rgba(0, 0, 0, 0.4);
            padding: 1.5rem;
        }

        .winner-section {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .winner-label {
            font-size: 0.9rem;
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        .winner-name {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .confidence {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .rationale {
            margin-top: 1rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: left;
        }

        .rationale-item {
            padding: 0.35rem 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .prediction-section {
            margin-top: 1.5rem;
        }

        .prediction-title {
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: #3498db;
        }

        .prediction-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .pred-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
        }

        .pred-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 0.5rem;
        }

        .pred-value {
            font-size: 2rem;
            font-weight: bold;
            color: #3498db;
        }

        .stats-breakdown {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .matchup-edge {
            background: rgba(52, 152, 219, 0.2);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            border-left: 3px solid #3498db;
        }

        .edge-item {
            font-size: 0.9rem;
        }

        .injuries {
            margin-top: 0.75rem;
        }

        .injury-item {
            font-size: 0.85rem;
            padding: 0.25rem 0;
            opacity: 0.9;
        }

        .injury-item a {
            color: #3498db;
            text-decoration: none;
        }

        .injury-item a:hover {
            text-decoration: underline;
        }

        .footer {
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 3rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #95a5a6;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .disclaimer {
            max-width: 800px;
            margin: 1rem auto 0;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .teams {
                flex-direction: column;
            }

            .stats {
                gap: 1rem;
            }

            .stat-value {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèà BRObet <span style="font-size: 0.4em; color: #95a5a6; font-weight: 400;">v0.01</span></h1>
            <p class="tagline">Advanced NFL Predictions & Matchup Analysis</p>
            <div class="week-indicator" id="weekIndicator">Loading...</div>
        </header>

        <div class="api-setup" id="apiSetup">
            <h3>üîë The Odds API Key Required</h3>
            <p style="color: #95a5a6;">
                Get your free API key from <a href="https://the-odds-api.com/" target="_blank" style="color: #3498db;">the-odds-api.com</a>
            </p>
            <input type="text" id="apiKeyInput" placeholder="Enter your API key here" />
            <button onclick="saveApiKey()">Save & Load Predictions</button>
        </div>

        <div class="scoreboard">
            <div class="scoreboard-content">
                <div>
                    <h2>üìà Prediction Accuracy</h2>
                    <p style="color: #95a5a6;">Season Performance</p>
                </div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="correct">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="total">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
        <div id="loading" class="loading">Enter your API key to load predictions...</div>
        <div id="picksummary" class="scoreboard" style="display: none;">
            <h2 style="margin-bottom: 1rem;">üéØ Top Picks</h2>
            <div id="picks-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.75rem;"></div>
        </div>
        <div id="games" class="games-grid"></div>

        <footer class="footer">
            <div>¬© 2025 BRObet. All rights reserved.</div>
            <div class="disclaimer">
                <strong>DISCLAIMER:</strong> This website is for informational and entertainment purposes only.
                BRObet provides NFL game predictions and analysis based on statistical models and publicly available data.
                No guarantees are made regarding the accuracy of predictions. Sports betting involves risk, and you should never
                wager more than you can afford to lose. We are not responsible for any losses incurred through the use of
                information provided on this site. Users assume all risk and liability for their betting decisions.
                This site does not operate as a gambling service and does not accept wagers. Please gamble responsibly and
                consult local laws regarding sports betting in your jurisdiction. By using this site, you acknowledge and
                agree to these terms.
            </div>
        </footer>
    </div>

    <script>
        // ===== CONFIGURATION =====
        let apiKey = localStorage.getItem('nfl_odds_api_key') || '';
        let predictions = JSON.parse(localStorage.getItem('nfl_predictions') || '{}');
        let accuracyStats = { correct: 0, total: 0 }; // Will be loaded from results.json

        // Team data (logos only - all stats fetched dynamically)
        const TEAM_DATA = {
            "Arizona Cardinals": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ari.png", color: "#97233F", lat: 33.5276, lon: -112.2626 },
            "Atlanta Falcons": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/atl.png", color: "#A71930", lat: 33.7554, lon: -84.4008 },
            "Baltimore Ravens": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/bal.png", color: "#241773", lat: 39.2780, lon: -76.6227 },
            "Buffalo Bills": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/buf.png", color: "#00338D", lat: 42.7738, lon: -78.7870 },
            "Carolina Panthers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/car.png", color: "#0085CA", lat: 35.2258, lon: -80.8530 },
            "Chicago Bears": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/chi.png", color: "#0B162A", lat: 41.8623, lon: -87.6167 },
            "Cincinnati Bengals": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/cin.png", color: "#FB4F14", lat: 39.0954, lon: -84.5160 },
            "Cleveland Browns": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/cle.png", color: "#311D00", lat: 41.5061, lon: -81.6995 },
            "Dallas Cowboys": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/dal.png", color: "#003594", lat: 32.7473, lon: -97.0945 },
            "Denver Broncos": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/den.png", color: "#FB4F14", lat: 39.7439, lon: -105.0201 },
            "Detroit Lions": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/det.png", color: "#0076B6", lat: 42.3400, lon: -83.0456 },
            "Green Bay Packers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/gb.png", color: "#203731", lat: 44.5013, lon: -88.0622 },
            "Houston Texans": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/hou.png", color: "#03202F", lat: 29.6847, lon: -95.4107 },
            "Indianapolis Colts": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ind.png", color: "#002C5F", lat: 39.7601, lon: -86.1639 },
            "Jacksonville Jaguars": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/jax.png", color: "#006778", lat: 30.3240, lon: -81.6373 },
            "Kansas City Chiefs": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/kc.png", color: "#E31837", lat: 39.0489, lon: -94.4839 },
            "Las Vegas Raiders": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lv.png", color: "#000000", lat: 36.0908, lon: -115.1831 },
            "Los Angeles Chargers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lac.png", color: "#0080C6", lat: 33.9535, lon: -118.3390 },
            "Los Angeles Rams": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lar.png", color: "#003594", lat: 33.9535, lon: -118.3390 },
            "Miami Dolphins": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/mia.png", color: "#008E97", lat: 25.9580, lon: -80.2389 },
            "Minnesota Vikings": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/min.png", color: "#4F2683", lat: 44.9738, lon: -93.2577 },
            "New England Patriots": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ne.png", color: "#002244", lat: 42.0909, lon: -71.2643 },
            "New Orleans Saints": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/no.png", color: "#D3BC8D", lat: 29.9511, lon: -90.0812 },
            "New York Giants": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/nyg.png", color: "#0B2265", lat: 40.8128, lon: -74.0742 },
            "New York Jets": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/nyj.png", color: "#125740", lat: 40.8128, lon: -74.0742 },
            "Philadelphia Eagles": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/phi.png", color: "#004C54", lat: 39.9008, lon: -75.1675 },
            "Pittsburgh Steelers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/pit.png", color: "#FFB612", lat: 40.4468, lon: -80.0158 },
            "San Francisco 49ers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/sf.png", color: "#AA0000", lat: 37.4032, lon: -121.9697 },
            "Seattle Seahawks": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/sea.png", color: "#002244", lat: 47.5952, lon: -122.3316 },
            "Tampa Bay Buccaneers": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/tb.png", color: "#D50A0A", lat: 27.9759, lon: -82.5033 },
            "Tennessee Titans": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ten.png", color: "#0C2340", lat: 36.1665, lon: -86.7713 },
            "Washington Commanders": { logo: "https://a.espncdn.com/i/teamlogos/nfl/500/wsh.png", color: "#5A1414", lat: 38.9076, lon: -76.8645 }
        };

        // League stats cache (comprehensive team statistics & rankings)
        let leagueStats = {
            teams: {}, // Will store comprehensive stats for each team
            rankings: {}, // Will store rankings (1-32) for each category
            hasData: false,
            lastUpdated: null
        };

        let injuries = {};

        // ===== FETCH GLOBAL ACCURACY =====
        async function fetchGlobalAccuracy() {
            try {
                const response = await fetch('results.json');
                if (response.ok) {
                    const data = await response.json();
                    accuracyStats = {
                        correct: data.correct || 0,
                        total: data.total || 0
                    };
                    updateAccuracyDisplay();
                    console.log(`üìä Loaded global accuracy: ${data.correct}/${data.total} (${data.accuracy}%)`);
                } else {
                    console.log('üìä No results.json found, starting with 0% accuracy');
                    updateAccuracyDisplay();
                }
            } catch (error) {
                console.log('üìä Could not load global accuracy, starting with 0%');
                updateAccuracyDisplay();
            }
        }

        // ===== INITIALIZATION =====
        // Load global accuracy first
        fetchGlobalAccuracy();

        if (apiKey) {
            document.getElementById('apiKeyInput').value = apiKey;
            document.getElementById('apiSetup').style.display = 'none';
            loadAllData();
        }

        function saveApiKey() {
            const input = document.getElementById('apiKeyInput');
            apiKey = input.value.trim();
            if (apiKey) {
                localStorage.setItem('nfl_odds_api_key', apiKey);
                document.getElementById('apiSetup').style.display = 'none';
                loadAllData();
            } else {
                showError('Please enter a valid API key');
            }
        }

        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => errorEl.style.display = 'none', 10000);
        }

        function updateAccuracyDisplay() {
            document.getElementById('correct').textContent = accuracyStats.correct;
            document.getElementById('total').textContent = accuracyStats.total;
            const accuracy = accuracyStats.total > 0 ? ((accuracyStats.correct / accuracyStats.total) * 100).toFixed(1) : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
        }

        // ===== MAIN DATA LOADING =====
        async function loadAllData() {
            try {
                document.getElementById('loading').textContent = 'üèà Loading NFL data...';
                console.log('=== STARTING DATA LOAD ===');

                // Step 1: Fetch league-wide team stats
                await fetchLeagueStats();

                // Step 2: Fetch injuries
                await fetchInjuries();

                // Step 3: Fetch upcoming games
                const games = await fetchGames();

                if (games.length === 0) {
                    document.getElementById('loading').textContent = 'No upcoming games in the next 7 days';
                    return;
                }

                // Step 4: Fetch odds
                let oddsData = [];
                try {
                    oddsData = await fetchOdds();
                } catch (e) {
                    console.warn('Could not fetch odds:', e.message);
                }

                // Step 5: Refresh global accuracy (GitHub Actions updates this)
                await fetchGlobalAccuracy();

                // Step 6: Display games with predictions
                await displayGames(games, oddsData);

                document.getElementById('loading').style.display = 'none';
                console.log('=== DATA LOAD COMPLETE ===');
            } catch (error) {
                console.error('Error loading data:', error);
                showError('Failed to load data: ' + error.message);
                document.getElementById('loading').textContent = 'Error loading data. Check console.';
            }
        }

        // ===== FETCH LEAGUE STATS =====
        async function fetchLeagueStats() {
            console.log('üìä Calculating comprehensive team statistics from season games...');

            try {
                // Initialize team stats trackers
                const teamStats = {};
                for (const teamName in TEAM_DATA) {
                    teamStats[teamName] = {
                        pointsScored: 0,
                        pointsAllowed: 0,
                        rushYards: 0,
                        rushYardsAllowed: 0,
                        passYards: 0,
                        passYardsAllowed: 0,
                        thirdDownConversions: 0,
                        thirdDownAttempts: 0,
                        redZoneScores: 0,
                        redZoneAttempts: 0,
                        sacksAllowed: 0,
                        sacksTaken: 0,
                        turnovers: 0,
                        takeaways: 0,
                        gamesPlayed: 0
                    };
                }

                // Fetch completed games from all weeks of the season
                const currentWeek = 15; // Update as season progresses
                let totalGames = 0;
                let statsProcessed = 0;

                for (let week = 1; week <= currentWeek; week++) {
                    try {
                        document.getElementById('loading').textContent = `üèà Loading Week ${week} of ${currentWeek}...`;

                        const response = await fetch(`https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2025&seasontype=2&week=${week}`);
                        const data = await response.json();

                        for (const event of data.events || []) {
                            const competition = event.competitions[0];

                            // Only process completed games
                            if (competition.status.type.completed) {
                                const homeComp = competition.competitors.find(c => c.homeAway === 'home');
                                const awayComp = competition.competitors.find(c => c.homeAway === 'away');

                                const homeTeam = homeComp.team.displayName;
                                const awayTeam = awayComp.team.displayName;

                                // Basic scores (from scoreboard)
                                const homeScore = parseInt(homeComp.score) || 0;
                                const awayScore = parseInt(awayComp.score) || 0;

                                if (teamStats[homeTeam]) {
                                    teamStats[homeTeam].pointsScored += homeScore;
                                    teamStats[homeTeam].pointsAllowed += awayScore;
                                    teamStats[homeTeam].gamesPlayed++;
                                }

                                if (teamStats[awayTeam]) {
                                    teamStats[awayTeam].pointsScored += awayScore;
                                    teamStats[awayTeam].pointsAllowed += homeScore;
                                    teamStats[awayTeam].gamesPlayed++;
                                }

                                // Fetch detailed statistics from box score
                                try {
                                    const statsUrl = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=${event.id}`;
                                    const statsResponse = await fetch(statsUrl);
                                    const statsData = await statsResponse.json();

                                    const boxscore = statsData.boxscore;
                                    if (boxscore && boxscore.teams) {
                                        const homeStats = boxscore.teams.find(t => t.homeAway === 'home');
                                        const awayStats = boxscore.teams.find(t => t.homeAway === 'away');

                                        // Temporary objects to store yards before assigning to defense
                                        const homeYards = { rush: 0, pass: 0 };
                                        const awayYards = { rush: 0, pass: 0 };

                                        // Parse offensive statistics for both teams
                                        if (homeStats && homeStats.statistics) {
                                            parseTeamStats(homeStats.statistics, teamStats[homeTeam], homeYards);
                                        }
                                        if (awayStats && awayStats.statistics) {
                                            parseTeamStats(awayStats.statistics, teamStats[awayTeam], awayYards);
                                        }

                                        // Assign defensive stats (opponent's yards = yards allowed)
                                        if (teamStats[homeTeam]) {
                                            teamStats[homeTeam].rushYardsAllowed += awayYards.rush;
                                            teamStats[homeTeam].passYardsAllowed += awayYards.pass;
                                        }
                                        if (teamStats[awayTeam]) {
                                            teamStats[awayTeam].rushYardsAllowed += homeYards.rush;
                                            teamStats[awayTeam].passYardsAllowed += homeYards.pass;
                                        }

                                        statsProcessed++;
                                    }
                                } catch (statErr) {
                                    console.warn(`Could not fetch stats for game ${event.id}:`, statErr.message);
                                }

                                totalGames++;
                            }
                        }
                    } catch (err) {
                        console.warn(`Could not fetch week ${week}:`, err.message);
                    }
                }

                console.log(`‚úÖ Processed ${totalGames} completed games, ${statsProcessed} with detailed stats`);

                document.getElementById('loading').textContent = `üìä Calculating team rankings and statistics...`;

                // Calculate per-game averages and percentages
                for (const teamName in teamStats) {
                    const stats = teamStats[teamName];
                    if (stats.gamesPlayed > 0) {
                        leagueStats.teams[teamName] = {
                            // Basic ratings
                            offensiveRating: stats.pointsScored / stats.gamesPlayed,
                            defensiveRating: stats.pointsAllowed / stats.gamesPlayed,

                            // Rushing stats
                            rushYPG: stats.rushYards / stats.gamesPlayed,
                            rushDefYPG: stats.rushYardsAllowed / stats.gamesPlayed,

                            // Passing stats
                            passYPG: stats.passYards / stats.gamesPlayed,
                            passDefYPG: stats.passYardsAllowed / stats.gamesPlayed,

                            // Situational stats
                            thirdDownPct: stats.thirdDownAttempts > 0 ? (stats.thirdDownConversions / stats.thirdDownAttempts) * 100 : 40,
                            redZonePct: stats.redZoneAttempts > 0 ? (stats.redZoneScores / stats.redZoneAttempts) * 100 : 50,

                            // Sacks
                            sacksAllowedPG: stats.sacksAllowed / stats.gamesPlayed,
                            sacksTakenPG: stats.sacksTaken / stats.gamesPlayed,

                            // Turnovers
                            turnoverDiff: stats.takeaways - stats.turnovers,

                            // Raw totals (for ranking)
                            gamesPlayed: stats.gamesPlayed
                        };
                    } else {
                        // Fallback defaults
                        leagueStats.teams[teamName] = {
                            offensiveRating: 24, defensiveRating: 24,
                            rushYPG: 120, rushDefYPG: 120,
                            passYPG: 220, passDefYPG: 220,
                            thirdDownPct: 40, redZonePct: 50,
                            sacksAllowedPG: 2.5, sacksTakenPG: 2.5,
                            turnoverDiff: 0, gamesPlayed: 0
                        };
                    }
                }

                // Calculate rankings (1-32) for each category
                calculateRankings();

                leagueStats.hasData = totalGames > 0;
                leagueStats.lastUpdated = new Date().toISOString();

                // Log sample for verification
                const sampleTeams = ['Detroit Lions', 'Buffalo Bills', 'Kansas City Chiefs'];
                sampleTeams.forEach(team => {
                    if (leagueStats.teams[team] && leagueStats.rankings[team]) {
                        const stats = leagueStats.teams[team];
                        const ranks = leagueStats.rankings[team];
                        console.log(`${team}: OFF #${ranks.rushOffRank} rush, #${ranks.passOffRank} pass | DEF #${ranks.rushDefRank} rush, #${ranks.passDefRank} pass`);
                    }
                });

                console.log(`‚úÖ Calculated comprehensive stats for ${Object.keys(leagueStats.teams).length} teams`);

            } catch (error) {
                console.error('Failed to calculate team stats:', error);
                // Fallback: use league average for all teams
                for (const teamName in TEAM_DATA) {
                    leagueStats.teams[teamName] = {
                        offensiveRating: 24, defensiveRating: 24,
                        rushYPG: 120, rushDefYPG: 120,
                        passYPG: 220, passDefYPG: 220,
                        thirdDownPct: 40, redZonePct: 50,
                        sacksAllowedPG: 2.5, sacksTakenPG: 2.5,
                        turnoverDiff: 0, gamesPlayed: 0
                    };
                    leagueStats.rankings[teamName] = {
                        rushOffRank: 16, passOffRank: 16,
                        rushDefRank: 16, passDefRank: 16
                    };
                }
                leagueStats.hasData = false;
            }
        }

        // Parse team statistics from box score
        function parseTeamStats(statistics, teamStats, yards) {
            // DEBUG: Log all stat names we see (only once)
            if (!window.statNamesLogged) {
                console.log('üìã Box score stat names available:', statistics.map(s => s.name).join(', '));
                window.statNamesLogged = true;
            }

            for (const stat of statistics) {
                const name = stat.name.toLowerCase();
                const value = parseFloat(stat.displayValue) || 0;

                if (name === 'rushingyards' || name === 'rushing yards' || name === 'totalrushingyards') {
                    teamStats.rushYards += value;
                    if (yards) yards.rush = value;
                }
                else if (name === 'passingyards' || name === 'passing yards' || name === 'totalpassingyards' || name === 'netpassingyards') {
                    teamStats.passYards += value;
                    if (yards) yards.pass = value;
                }
                else if (name === 'thirddowneff') {
                    // Format is "X-Y" where X is conversions, Y is attempts
                    const parts = stat.displayValue.split('-');
                    if (parts.length === 2) {
                        teamStats.thirdDownConversions += parseInt(parts[0]) || 0;
                        teamStats.thirdDownAttempts += parseInt(parts[1]) || 0;
                    }
                }
                else if (name === 'redzoneeff' || name === 'redzonemade-att') {
                    const parts = stat.displayValue.split('-');
                    if (parts.length === 2) {
                        teamStats.redZoneScores += parseInt(parts[0]) || 0;
                        teamStats.redZoneAttempts += parseInt(parts[1]) || 0;
                    }
                }
                else if (name === 'sacks' || name === 'sacks-yardslost') {
                    // This is sacks ALLOWED by the offense
                    const parts = stat.displayValue.split('-');
                    teamStats.sacksAllowed += parseInt(parts[0]) || 0;
                }
                else if (name === 'interceptions' || name === 'interceptionthrown') {
                    teamStats.turnovers += value;
                }
                else if (name === 'fumblelost' || name === 'fumbleslost') {
                    teamStats.turnovers += value;
                }
                else if (name === 'defensiveinterceptions') {
                    teamStats.takeaways += value;
                }
                else if (name === 'defensivefumblerecoveries' || name === 'fumblerecoveries') {
                    teamStats.takeaways += value;
                }
                else if (name === 'defensivesacks' || name === 'totalsacks') {
                    teamStats.sacksTaken += value;
                }
            }

            // Defensive yards allowed are calculated as opponent's yards
            // This will be handled when we process both teams
        }

        // Calculate rankings (1-32) for all categories
        function calculateRankings() {
            const teams = Object.keys(leagueStats.teams);

            // Initialize rankings object
            teams.forEach(team => {
                leagueStats.rankings[team] = {
                    rushOffRank: 0,
                    passOffRank: 0,
                    rushDefRank: 0,
                    passDefRank: 0
                };
            });

            // Rush offense (higher yards = better rank)
            const rushOffRanked = [...teams].sort((a, b) => leagueStats.teams[b].rushYPG - leagueStats.teams[a].rushYPG);
            rushOffRanked.forEach((team, idx) => leagueStats.rankings[team].rushOffRank = idx + 1);

            // Pass offense (higher yards = better rank)
            const passOffRanked = [...teams].sort((a, b) => leagueStats.teams[b].passYPG - leagueStats.teams[a].passYPG);
            passOffRanked.forEach((team, idx) => leagueStats.rankings[team].passOffRank = idx + 1);

            // Rush defense (lower yards allowed = better rank)
            const rushDefRanked = [...teams].sort((a, b) => leagueStats.teams[a].rushDefYPG - leagueStats.teams[b].rushDefYPG);
            rushDefRanked.forEach((team, idx) => leagueStats.rankings[team].rushDefRank = idx + 1);

            // Pass defense (lower yards allowed = better rank)
            const passDefRanked = [...teams].sort((a, b) => leagueStats.teams[a].passDefYPG - leagueStats.teams[b].passDefYPG);
            passDefRanked.forEach((team, idx) => leagueStats.rankings[team].passDefRank = idx + 1);

            // DEBUG: Log rankings for comparison with ESPN
            console.log('\nüìä CALCULATED RANKINGS (compare with ESPN):');
            console.log('\nüèÉ Rush Offense (YPG):');
            rushOffRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].rushYPG.toFixed(1)} YPG`);
            });
            console.log('\n‚úàÔ∏è Pass Offense (YPG):');
            passOffRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].passYPG.toFixed(1)} YPG`);
            });
            console.log('\nüõ°Ô∏è Rush Defense (YPG Allowed):');
            rushDefRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].rushDefYPG.toFixed(1)} YPG allowed`);
            });
            console.log('\nüö´ Pass Defense (YPG Allowed):');
            passDefRanked.slice(0, 10).forEach((team, idx) => {
                console.log(`  #${idx + 1}: ${team} - ${leagueStats.teams[team].passDefYPG.toFixed(1)} YPG allowed`);
            });

            // Show specific team if it's in a game this week
            const dolphins = leagueStats.teams['Miami Dolphins'];
            if (dolphins) {
                console.log('\nüê¨ Miami Dolphins Stats:');
                console.log(`  Rush Off: ${dolphins.rushYPG.toFixed(1)} YPG (Rank #${leagueStats.rankings['Miami Dolphins'].rushOffRank})`);
                console.log(`  Pass Off: ${dolphins.passYPG.toFixed(1)} YPG (Rank #${leagueStats.rankings['Miami Dolphins'].passOffRank})`);
                console.log(`  Rush Def: ${dolphins.rushDefYPG.toFixed(1)} YPG allowed (Rank #${leagueStats.rankings['Miami Dolphins'].rushDefRank})`);
                console.log(`  Pass Def: ${dolphins.passDefYPG.toFixed(1)} YPG allowed (Rank #${leagueStats.rankings['Miami Dolphins'].passDefRank})`);
                console.log(`  Games: ${dolphins.gamesPlayed}`);
            }
        }

        // ===== FETCH INJURIES =====
        async function fetchInjuries() {
            console.log('üè• Fetching injuries from ESPN...');

            try {
                const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/football/nfl/news?limit=100');
                const data = await response.json();

                for (const article of data.articles || []) {
                    if (article.headline.toLowerCase().includes('injury') ||
                        article.headline.toLowerCase().includes('out') ||
                        article.headline.toLowerCase().includes('questionable')) {

                        for (const teamName in TEAM_DATA) {
                            if (article.headline.includes(teamName) ||
                                (article.description && article.description.includes(teamName))) {

                                if (!injuries[teamName]) {
                                    injuries[teamName] = [];
                                }

                                injuries[teamName].push({
                                    headline: article.headline,
                                    link: article.links?.web?.href || '#',
                                    description: article.description || ''
                                });
                            }
                        }
                    }
                }

                console.log(`‚úÖ Found injury reports for ${Object.keys(injuries).length} teams`);
            } catch (error) {
                console.warn('Could not fetch injuries:', error.message);
            }
        }

        // ===== FETCH GAMES =====
        async function fetchGames() {
            console.log('üì• Fetching games from ESPN...');

            const games = [];
            const now = new Date();
            const sevenDaysFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

            const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard');
            const data = await response.json();

            if (data.week && data.week.number) {
                document.getElementById('weekIndicator').textContent = `Week ${data.week.number}`;
            }

            for (const event of data.events || []) {
                const gameDate = new Date(event.date);
                if (gameDate > now && gameDate < sevenDaysFromNow) {
                    games.push(event);
                }
            }

            console.log(`‚úÖ Found ${games.length} upcoming games`);
            return games;
        }

        // ===== FETCH ODDS =====
        async function fetchOdds() {
            if (!apiKey) return [];

            console.log('üí∞ Fetching odds...');
            const response = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_nfl/odds/?apiKey=${apiKey}&regions=us&markets=spreads,totals,h2h`);

            if (!response.ok) {
                throw new Error('Failed to fetch odds');
            }

            const data = await response.json();
            console.log(`‚úÖ Fetched odds for ${data.length} games`);
            return data;
        }

        // ===== FETCH WEATHER =====
        async function fetchWeather(homeTeam, gameDate) {
            const teamInfo = TEAM_DATA[homeTeam];
            if (!teamInfo) return null;

            try {
                const date = new Date(gameDate);
                const dateStr = date.toISOString().split('T')[0];

                const url = `https://api.open-meteo.com/v1/forecast?latitude=${teamInfo.lat}&longitude=${teamInfo.lon}&hourly=temperature_2m,precipitation_probability,windspeed_10m,weathercode&temperature_unit=fahrenheit&windspeed_unit=mph&timezone=America/New_York&start_date=${dateStr}&end_date=${dateStr}`;

                const response = await fetch(url);
                const data = await response.json();

                const hour = date.getHours();
                const temp = data.hourly.temperature_2m[hour] || 70;
                const precip = data.hourly.precipitation_probability[hour] || 0;
                const wind = data.hourly.windspeed_10m[hour] || 0;
                const code = data.hourly.weathercode[hour] || 0;

                let condition = 'Clear';
                let rain = 0;
                let snow = 0;

                if (code >= 71 && code <= 77) { condition = 'Snow'; snow = 1; }
                else if (code >= 61 && code <= 67) { condition = 'Rain'; rain = 0.5; }
                else if (code >= 80 && code <= 99) { condition = 'Heavy Rain'; rain = 1; }
                else if (code >= 45 && code <= 48) condition = 'Fog';

                return {
                    temp: Math.round(temp),
                    precipitation: precip,
                    windSpeed: Math.round(wind),
                    condition,
                    rain,
                    snow
                };
            } catch (error) {
                console.warn('Weather fetch failed:', error.message);
                return null;
            }
        }

        // ===== ANALYZE INJURY IMPACT =====
        function analyzeInjuryImpact(teamName) {
            const teamInjuries = injuries[teamName] || [];
            let impact = { points: 0, notes: [] };

            for (const injury of teamInjuries) {
                const text = (injury.headline + ' ' + injury.description).toLowerCase();

                // QB injuries - huge impact
                if (text.includes('quarterback') || text.includes(' qb ')) {
                    if (text.includes('out') || text.includes('ruled out')) {
                        impact.points -= 8;
                        impact.notes.push('Starting QB out (-8 pts)');
                    } else if (text.includes('questionable') || text.includes('doubtful')) {
                        impact.points -= 4;
                        impact.notes.push('Starting QB questionable (-4 pts)');
                    }
                }

                // RB injuries - big impact
                else if (text.includes('running back') || text.includes(' rb ')) {
                    if (text.includes('out') || text.includes('ruled out')) {
                        impact.points -= 4;
                        impact.notes.push('Key RB out (-4 pts)');
                    } else if (text.includes('questionable')) {
                        impact.points -= 2;
                        impact.notes.push('Key RB questionable (-2 pts)');
                    }
                }

                // WR injuries - significant for passing
                else if (text.includes('wide receiver') || text.includes(' wr ') || text.includes('receiver')) {
                    if (text.includes('out') || text.includes('ruled out')) {
                        impact.points -= 3;
                        impact.notes.push('Key WR out (-3 pts)');
                    } else if (text.includes('questionable')) {
                        impact.points -= 1.5;
                        impact.notes.push('Key WR questionable (-1.5 pts)');
                    }
                }
            }

            return impact;
        }

        // ===== GENERATE PREDICTION (EFFICIENCY RATING METHOD) =====
        function generatePrediction(game, odds, weather) {
            const competition = game.competitions[0];
            const homeComp = competition.competitors.find(c => c.homeAway === 'home');
            const awayComp = competition.competitors.find(c => c.homeAway === 'away');

            const homeTeam = homeComp.team.displayName;
            const awayTeam = awayComp.team.displayName;

            const homeRecord = homeComp.records?.[0]?.summary || '0-0';
            const awayRecord = awayComp.records?.[0]?.summary || '0-0';

            // Check if we have real data for both teams
            const homeStats = leagueStats.teams[homeTeam];
            const awayStats = leagueStats.teams[awayTeam];
            const homeRankings = leagueStats.rankings[homeTeam];
            const awayRankings = leagueStats.rankings[awayTeam];

            // If missing data, return error instead of using fake fallbacks
            if (!homeStats || !awayStats || !homeRankings || !awayRankings) {
                const missingTeams = [];
                if (!homeStats) missingTeams.push(homeTeam);
                if (!awayStats) missingTeams.push(awayTeam);

                return {
                    error: true,
                    homeTeam,
                    awayTeam,
                    homeRecord,
                    awayRecord,
                    message: `Missing data for: ${missingTeams.join(', ')}`,
                    missingTeams,
                    retryable: true
                };
            }

            let prediction = {
                homeTeam,
                awayTeam,
                homeRecord,
                awayRecord,
                vegasSpread: 'N/A',
                vegasTotal: 'N/A',
                vegasHomeScore: null,
                vegasAwayScore: null,
                weather: weather,
                rationale: [],
                edges: [],
                calculations: [],
                deviation: [],
                injuries: {
                    home: injuries[homeTeam] || [],
                    away: injuries[awayTeam] || []
                }
            };

            // Parse Vegas odds (for comparison only, NOT as base)
            if (odds) {
                const spreadsMarket = odds.bookmakers?.[0]?.markets?.find(m => m.key === 'spreads');
                const totalsMarket = odds.bookmakers?.[0]?.markets?.find(m => m.key === 'totals');

                if (spreadsMarket) {
                    const homeSpread = spreadsMarket.outcomes.find(o => o.name === homeTeam);
                    prediction.vegasSpread = homeSpread?.point || 'N/A';
                }
                if (totalsMarket) {
                    prediction.vegasTotal = totalsMarket.outcomes[0]?.point || 'N/A';
                }

                // Calculate Vegas implied scores
                if (prediction.vegasSpread !== 'N/A' && prediction.vegasTotal !== 'N/A') {
                    const spread = parseFloat(prediction.vegasSpread);
                    const total = parseFloat(prediction.vegasTotal);
                    prediction.vegasHomeScore = Math.round((total - spread) / 2);
                    prediction.vegasAwayScore = Math.round((total + spread) / 2);
                }
            }

            // ===== EFFICIENCY RATING FORMULA =====
            // Away projected points = (Away offensive rating + Home defensive rating) / 2
            // Home projected points = (Home offensive rating + Away defensive rating) / 2 + home field advantage

            const baseAwayScore = (awayStats.offensiveRating + homeStats.defensiveRating) / 2;
            const baseHomeScore = (homeStats.offensiveRating + awayStats.defensiveRating) / 2;

            prediction.calculations.push(`üìä Efficiency Rating Formula:`);
            prediction.calculations.push(`${awayTeam} base: (${awayStats.offensiveRating.toFixed(1)} OFF + ${homeStats.defensiveRating.toFixed(1)} DEF allowed) / 2 = ${baseAwayScore.toFixed(1)}`);
            prediction.calculations.push(`${homeTeam} base: (${homeStats.offensiveRating.toFixed(1)} OFF + ${awayStats.defensiveRating.toFixed(1)} DEF allowed) / 2 = ${baseHomeScore.toFixed(1)}`);

            let ourHomeScore = baseHomeScore;
            let ourAwayScore = baseAwayScore;

            // Home field advantage (2.5-3 pts)
            const homeFieldAdv = 2.5;
            ourHomeScore += homeFieldAdv;
            prediction.calculations.push(`Home field advantage: +${homeFieldAdv} pts to ${homeTeam}`);

            // ===== RUSH/PASS MATCHUP ANALYSIS =====
            // Determine weather weights for rush vs pass importance
            let rushWeight = 1.0;
            let passWeight = 1.0;

            if (weather) {
                if (weather.snow) {
                    rushWeight = 2.0;
                    passWeight = 0.4;
                    prediction.calculations.push(`‚õÑ Snow weather: Rush √ó2.0, Pass √ó0.4`);
                } else if (weather.rain > 0.5) {
                    rushWeight = 1.5;
                    passWeight = 0.7;
                    prediction.calculations.push(`üåßÔ∏è Rain: Rush √ó1.5, Pass √ó0.7`);
                }

                if (weather.windSpeed > 20) {
                    passWeight *= 0.5;
                    prediction.calculations.push(`üí® High winds (${weather.windSpeed}mph): Pass √ó0.5`);
                }
            }

            // Home team rush offense vs away team rush defense
            if (leagueStats.hasData && homeRankings.rushOffRank && awayRankings.rushDefRank) {
                const gap = awayRankings.rushDefRank - homeRankings.rushOffRank;
                const rawAdvantage = gap * 0.15; // 0.15 pts per rank difference
                const advantage = rawAdvantage * rushWeight;

                if (Math.abs(gap) > 5) {
                    ourHomeScore += advantage;
                    const favored = gap > 0 ? homeTeam : awayTeam;
                    prediction.calculations.push(`${homeTeam} #${homeRankings.rushOffRank} rush O vs ${awayTeam} #${awayRankings.rushDefRank} rush D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} rush matchup advantage (#${Math.min(homeRankings.rushOffRank, awayRankings.rushDefRank)} vs #${Math.max(homeRankings.rushOffRank, awayRankings.rushDefRank)})`);
                    }
                }
            }

            // Home team pass offense vs away team pass defense
            if (leagueStats.hasData && homeRankings.passOffRank && awayRankings.passDefRank) {
                const gap = awayRankings.passDefRank - homeRankings.passOffRank;
                const rawAdvantage = gap * 0.15;
                const advantage = rawAdvantage * passWeight;

                if (Math.abs(gap) > 5) {
                    ourHomeScore += advantage;
                    const favored = gap > 0 ? homeTeam : awayTeam;
                    prediction.calculations.push(`${homeTeam} #${homeRankings.passOffRank} pass O vs ${awayTeam} #${awayRankings.passDefRank} pass D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} pass matchup advantage (#${Math.min(homeRankings.passOffRank, awayRankings.passDefRank)} vs #${Math.max(homeRankings.passOffRank, awayRankings.passDefRank)})`);
                    }
                }
            }

            // Away team rush offense vs home team rush defense
            if (leagueStats.hasData && awayRankings.rushOffRank && homeRankings.rushDefRank) {
                const gap = homeRankings.rushDefRank - awayRankings.rushOffRank;
                const rawAdvantage = gap * 0.15;
                const advantage = rawAdvantage * rushWeight;

                if (Math.abs(gap) > 5) {
                    ourAwayScore += advantage;
                    const favored = gap > 0 ? awayTeam : homeTeam;
                    prediction.calculations.push(`${awayTeam} #${awayRankings.rushOffRank} rush O vs ${homeTeam} #${homeRankings.rushDefRank} rush D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} rush matchup advantage (#${Math.min(awayRankings.rushOffRank, homeRankings.rushDefRank)} vs #${Math.max(awayRankings.rushOffRank, homeRankings.rushDefRank)})`);
                    }
                }
            }

            // Away team pass offense vs home team pass defense
            if (leagueStats.hasData && awayRankings.passOffRank && homeRankings.passDefRank) {
                const gap = homeRankings.passDefRank - awayRankings.passOffRank;
                const rawAdvantage = gap * 0.15;
                const advantage = rawAdvantage * passWeight;

                if (Math.abs(gap) > 5) {
                    ourAwayScore += advantage;
                    const favored = gap > 0 ? awayTeam : homeTeam;
                    prediction.calculations.push(`${awayTeam} #${awayRankings.passOffRank} pass O vs ${homeTeam} #${homeRankings.passDefRank} pass D: ${advantage > 0 ? '+' : ''}${advantage.toFixed(1)} pts`);
                    if (Math.abs(gap) > 10) {
                        prediction.edges.push(`${favored} pass matchup advantage (#${Math.min(awayRankings.passOffRank, homeRankings.passDefRank)} vs #${Math.max(awayRankings.passOffRank, homeRankings.passDefRank)})`);
                    }
                }
            }

            // ===== SITUATIONAL EFFICIENCY ADJUSTMENTS =====
            // Third down efficiency
            if (homeStats.thirdDownPct > 45) {
                ourHomeScore += 1.5;
                prediction.calculations.push(`${homeTeam} 3rd down efficiency (${homeStats.thirdDownPct.toFixed(1)}%): +1.5 pts`);
            } else if (homeStats.thirdDownPct < 35) {
                ourHomeScore -= 1.5;
                prediction.calculations.push(`${homeTeam} poor 3rd down % (${homeStats.thirdDownPct.toFixed(1)}%): -1.5 pts`);
            }

            if (awayStats.thirdDownPct > 45) {
                ourAwayScore += 1.5;
                prediction.calculations.push(`${awayTeam} 3rd down efficiency (${awayStats.thirdDownPct.toFixed(1)}%): +1.5 pts`);
            } else if (awayStats.thirdDownPct < 35) {
                ourAwayScore -= 1.5;
                prediction.calculations.push(`${awayTeam} poor 3rd down % (${awayStats.thirdDownPct.toFixed(1)}%): -1.5 pts`);
            }

            // Red zone efficiency
            if (homeStats.redZonePct > 60) {
                ourHomeScore += 1.5;
                prediction.calculations.push(`${homeTeam} red zone efficiency (${homeStats.redZonePct.toFixed(1)}%): +1.5 pts`);
            } else if (homeStats.redZonePct < 45) {
                ourHomeScore -= 1.5;
                prediction.calculations.push(`${homeTeam} poor red zone % (${homeStats.redZonePct.toFixed(1)}%): -1.5 pts`);
            }

            if (awayStats.redZonePct > 60) {
                ourAwayScore += 1.5;
                prediction.calculations.push(`${awayTeam} red zone efficiency (${awayStats.redZonePct.toFixed(1)}%): +1.5 pts`);
            } else if (awayStats.redZonePct < 45) {
                ourAwayScore -= 1.5;
                prediction.calculations.push(`${awayTeam} poor red zone % (${awayStats.redZonePct.toFixed(1)}%): -1.5 pts`);
            }

            // Sack differential (pass rush vs O-line)
            const homeSackDiff = (awayStats.sacksTakenPG || 0) - (homeStats.sacksAllowedPG || 0);
            const awaySackDiff = (homeStats.sacksTakenPG || 0) - (awayStats.sacksAllowedPG || 0);

            if (homeSackDiff > 1) {
                ourHomeScore += 1;
                prediction.calculations.push(`${homeTeam} pass rush advantage (sack diff +${homeSackDiff.toFixed(1)}): +1 pt`);
            } else if (homeSackDiff < -1) {
                ourHomeScore -= 1;
                prediction.calculations.push(`${awayTeam} O-line advantage (sack diff ${homeSackDiff.toFixed(1)}): -1 pt to ${homeTeam}`);
            }

            if (awaySackDiff > 1) {
                ourAwayScore += 1;
                prediction.calculations.push(`${awayTeam} pass rush advantage (sack diff +${awaySackDiff.toFixed(1)}): +1 pt`);
            } else if (awaySackDiff < -1) {
                ourAwayScore -= 1;
                prediction.calculations.push(`${homeTeam} O-line advantage (sack diff ${awaySackDiff.toFixed(1)}): -1 pt to ${awayTeam}`);
            }

            // Turnover differential (use cautiously - high variance)
            if (homeStats.turnoverDiff > 8) {
                ourHomeScore += 0.5;
                prediction.calculations.push(`${homeTeam} strong turnover diff (+${homeStats.turnoverDiff}): +0.5 pts`);
            } else if (homeStats.turnoverDiff < -8) {
                ourHomeScore -= 0.5;
                prediction.calculations.push(`${homeTeam} poor turnover diff (${homeStats.turnoverDiff}): -0.5 pts`);
            }

            if (awayStats.turnoverDiff > 8) {
                ourAwayScore += 0.5;
                prediction.calculations.push(`${awayTeam} strong turnover diff (+${awayStats.turnoverDiff}): +0.5 pts`);
            } else if (awayStats.turnoverDiff < -8) {
                ourAwayScore -= 0.5;
                prediction.calculations.push(`${awayTeam} poor turnover diff (${awayStats.turnoverDiff}): -0.5 pts`);
            }

            // ===== WEATHER SCORING REDUCTION =====
            if (weather) {
                if (weather.snow || weather.rain > 0.5 || weather.windSpeed > 20) {
                    let weatherImpact = 0;

                    if (weather.snow) {
                        weatherImpact = -4; // Heavy snow reduces scoring
                        prediction.calculations.push(`${weather.condition}: -4 pts total scoring (favors defense)`);
                    } else if (weather.rain > 0.5) {
                        weatherImpact = -2;
                        prediction.calculations.push(`${weather.condition}: -2 pts total scoring`);
                    }

                    if (weather.windSpeed > 20) {
                        weatherImpact -= 2;
                        prediction.calculations.push(`High winds (${weather.windSpeed}mph): -2 pts scoring`);
                    }

                    // Split weather impact between both teams
                    ourHomeScore += weatherImpact / 2;
                    ourAwayScore += weatherImpact / 2;
                }
            }

            // ===== INJURY IMPACT =====
            const homeInjuryImpact = analyzeInjuryImpact(homeTeam);
            const awayInjuryImpact = analyzeInjuryImpact(awayTeam);

            if (homeInjuryImpact.points !== 0) {
                ourHomeScore += homeInjuryImpact.points;
                homeInjuryImpact.notes.forEach(note => prediction.calculations.push(`${homeTeam}: ${note}`));
            }

            if (awayInjuryImpact.points !== 0) {
                ourAwayScore += awayInjuryImpact.points;
                awayInjuryImpact.notes.forEach(note => prediction.calculations.push(`${awayTeam}: ${note}`));
            }

            // Finalize our prediction
            prediction.homeScore = Math.max(10, Math.round(ourHomeScore));
            prediction.awayScore = Math.max(10, Math.round(ourAwayScore));

            if (prediction.homeScore === prediction.awayScore) {
                prediction.homeScore += 1;
                prediction.calculations.push(`Tie-breaker: +1 to ${homeTeam}`);
            }

            prediction.winner = prediction.homeScore > prediction.awayScore ? homeTeam : awayTeam;
            const margin = Math.abs(prediction.homeScore - prediction.awayScore);

            // ===== DEVIATION ANALYSIS (Compare to Vegas) =====
            if (prediction.vegasHomeScore && prediction.vegasAwayScore) {
                const scoreDiff = (prediction.homeScore - prediction.awayScore) - (prediction.vegasHomeScore - prediction.vegasAwayScore);
                const totalDiff = (prediction.homeScore + prediction.awayScore) - (prediction.vegasHomeScore + prediction.vegasAwayScore);

                prediction.deviation.push(`BRObet: ${homeTeam} ${prediction.homeScore}, ${awayTeam} ${prediction.awayScore}`);
                prediction.deviation.push(`Vegas: ${homeTeam} ${prediction.vegasHomeScore}, ${awayTeam} ${prediction.vegasAwayScore}`);

                if (Math.abs(scoreDiff) > 3) {
                    const favorsTeam = scoreDiff > 0 ? homeTeam : awayTeam;
                    prediction.deviation.push(`üî• BRObet favors ${favorsTeam} ${Math.abs(scoreDiff).toFixed(1)} pts more than Vegas`);
                    prediction.rationale.push(`Significant deviation from Vegas (${Math.abs(scoreDiff).toFixed(1)} pt spread difference)`);
                } else {
                    prediction.deviation.push(`‚úì Close agreement with Vegas (${Math.abs(scoreDiff).toFixed(1)} pt spread difference)`);
                }

                if (Math.abs(totalDiff) > 6) {
                    const direction = totalDiff > 0 ? 'OVER' : 'UNDER';
                    prediction.deviation.push(`üìä ${direction} Vegas total by ${Math.abs(totalDiff).toFixed(1)} pts`);
                }
            }

            // Build rationale
            prediction.rationale.push(`${prediction.winner} by ${margin} points`);

            if (prediction.vegasSpread !== 'N/A') {
                const vegasFav = parseFloat(prediction.vegasSpread) < 0 ? homeTeam : awayTeam;
                prediction.rationale.push(`Vegas favors: ${vegasFav} by ${Math.abs(parseFloat(prediction.vegasSpread))} pts`);
            }

            // Add efficiency context to rationale
            const winnerStats = prediction.winner === homeTeam ? homeStats : awayStats;
            prediction.rationale.push(`${prediction.winner} averages ${winnerStats.offensiveRating.toFixed(1)} ppg`);

            // Confidence based on prediction margin and edge count
            let confidenceScore = margin;
            if (prediction.edges.length >= 2) confidenceScore += 5;
            if (prediction.edges.length >= 3) confidenceScore += 3;

            if (confidenceScore >= 14) prediction.confidence = 'High';
            else if (confidenceScore >= 8) prediction.confidence = 'Medium';
            else prediction.confidence = 'Low';

            return prediction;
        }

        // ===== DISPLAY GAMES =====
        async function displayGames(games, oddsData) {
            const gamesContainer = document.getElementById('games');
            const picksList = document.getElementById('picks-list');
            const picksSummary = document.getElementById('picksummary');

            gamesContainer.innerHTML = '';
            picksList.innerHTML = '';

            if (games.length === 0) {
                gamesContainer.innerHTML = '<div style="text-align: center; padding: 3rem;">No upcoming games</div>';
                return;
            }

            const gamesWithPredictions = [];

            for (const game of games) {
                const competition = game.competitions[0];
                const homeComp = competition.competitors.find(c => c.homeAway === 'home');
                const homeTeam = homeComp.team.displayName;

                const gameOdds = oddsData.find(o =>
                    o.home_team === homeTeam ||
                    (o.home_team.includes(homeTeam.split(' ').pop()) && o.commence_time &&
                     Math.abs(new Date(o.commence_time) - new Date(game.date)) < 3600000)
                );

                const weather = await fetchWeather(homeTeam, game.date);
                const prediction = generatePrediction(game, gameOdds, weather);

                const gameId = game.id;

                // Only save valid predictions (not errors)
                if (!prediction.error) {
                    savePrediction(gameId, game.date, prediction);
                }

                gamesWithPredictions.push({ game, prediction, gameId });
            }

            const confidenceOrder = { 'High': 0, 'Medium': 1, 'Low': 2 };
            gamesWithPredictions.sort((a, b) => {
                const dateA = new Date(a.game.date);
                const dateB = new Date(b.game.date);
                if (dateA.toDateString() !== dateB.toDateString()) {
                    return dateA - dateB;
                }
                // Show errors last, then sort by confidence
                if (a.prediction.error && !b.prediction.error) return 1;
                if (!a.prediction.error && b.prediction.error) return -1;
                if (a.prediction.error && b.prediction.error) return 0;
                return confidenceOrder[a.prediction.confidence] - confidenceOrder[b.prediction.confidence];
            });

            gamesWithPredictions.forEach(({ prediction, gameId }) => {
                // Skip error predictions in picks summary
                if (prediction.error) return;
                const teamColor = TEAM_DATA[prediction.winner]?.color || '#3498db';
                const loser = prediction.winner === prediction.homeTeam ? prediction.awayTeam : prediction.homeTeam;

                picksList.innerHTML += `
                    <div onclick="document.getElementById('${gameId}').scrollIntoView({behavior: 'smooth', block: 'center'})"
                         style="background: rgba(255,255,255,0.05); padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; border-left: 4px solid ${teamColor}; transition: all 0.2s;"
                         onmouseover="this.style.background='rgba(255,255,255,0.1)'"
                         onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                        <div style="font-weight: bold; font-size: 1.1rem;">${prediction.winner}</div>
                        <div style="font-size: 0.85rem; opacity: 0.9;">over ${loser}</div>
                        <div style="font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem;">
                            ${prediction.homeScore}-${prediction.awayScore} ‚Ä¢ ${prediction.confidence}
                        </div>
                    </div>
                `;
            });
            picksSummary.style.display = 'block';

            gamesWithPredictions.forEach(({ game, prediction, gameId }) => {
                gamesContainer.innerHTML += createGameCard(game, prediction, gameId);
            });
        }

        function createGameCard(game, prediction, gameId) {
            // Handle error predictions
            if (prediction.error) {
                const homeLogo = TEAM_DATA[prediction.homeTeam]?.logo;
                const awayLogo = TEAM_DATA[prediction.awayTeam]?.logo;
                const gameDate = new Date(game.date);
                const gameTime = gameDate.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });

                return `
                    <div id="${gameId}" class="game-card" style="background: linear-gradient(135deg, #e74c3c22 0%, #e74c3c44 100%); border: 2px solid #e74c3c88;">
                        <div class="game-header" style="background-color: #e74c3c; text-align: center;">
                            <div class="game-meta">
                                <div class="badge">üìÖ ${gameTime}</div>
                                <div class="badge" style="background: #c0392b;">‚ö†Ô∏è DATA ERROR</div>
                            </div>
                            <div class="teams">
                                <div class="team">
                                    ${awayLogo ? `<img src="${awayLogo}" alt="${prediction.awayTeam}" class="team-logo">` : ''}
                                    <div>
                                        <div class="team-name">${prediction.awayTeam}</div>
                                        <div class="team-record">${prediction.awayRecord}</div>
                                    </div>
                                </div>
                                <div style="font-size: 1.5rem; color: white;">@</div>
                                <div class="team">
                                    ${homeLogo ? `<img src="${homeLogo}" alt="${prediction.homeTeam}" class="team-logo">` : ''}
                                    <div>
                                        <div class="team-name">${prediction.homeTeam}</div>
                                        <div class="team-record">${prediction.homeRecord}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="padding: 2rem; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: #e74c3c; margin-bottom: 1rem;">‚ö†Ô∏è Unable to Generate Prediction</div>
                            <div style="color: #999; margin-bottom: 1rem;">${prediction.message}</div>
                            <div style="color: #666; font-size: 0.9rem; margin-bottom: 1.5rem;">
                                Real team data is required for accurate predictions. Using fallback averages would produce misleading results.
                            </div>
                            <button onclick="location.reload()" style="background: #3498db; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-size: 1rem; font-weight: bold;">
                                üîÑ Retry Now
                            </button>
                            <div id="retry-timer-${gameId}" style="color: #999; font-size: 0.9rem; margin-top: 1rem;">
                                Auto-retry in <span id="countdown-${gameId}">15:00</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            const teamColor = TEAM_DATA[prediction.homeTeam]?.color || '#3498db';
            const homeLogo = TEAM_DATA[prediction.homeTeam]?.logo;
            const awayLogo = TEAM_DATA[prediction.awayTeam]?.logo;

            const gameDate = new Date(game.date);
            const gameTime = gameDate.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            });

            const confidenceClass = `confidence-${prediction.confidence.toLowerCase()}`;

            let weatherHTML = '';
            if (prediction.weather) {
                const w = prediction.weather;
                let weatherIcon = '‚òÄÔ∏è';
                if (w.condition === 'Snow') weatherIcon = '‚ùÑÔ∏è';
                else if (w.condition.includes('Rain')) weatherIcon = 'üåßÔ∏è';
                else if (w.condition === 'Fog') weatherIcon = 'üå´Ô∏è';

                weatherHTML = `<div class="badge" style="background: rgba(255,255,255,0.2);">${weatherIcon} ${w.temp}¬∞F ${w.condition}${w.windSpeed > 15 ? ` ‚Ä¢ ${w.windSpeed}mph` : ''}</div>`;
            }

            // Removed fallback badge - using reliable hardcoded rankings

            let rationaleHTML = '';
            if (prediction.rationale.length > 0) {
                rationaleHTML = '<div class="rationale"><strong>Summary:</strong>';
                prediction.rationale.forEach(reason => {
                    rationaleHTML += `<div class="rationale-item">‚Ä¢ ${reason}</div>`;
                });
                rationaleHTML += '</div>';
            }

            let calculationsHTML = '';
            if (prediction.calculations.length > 0) {
                calculationsHTML = '<div class="rationale" style="margin-top: 1rem;"><strong>How We Calculated This:</strong>';
                prediction.calculations.forEach(calc => {
                    calculationsHTML += `<div class="rationale-item">‚Üí ${calc}</div>`;
                });
                calculationsHTML += '</div>';
            }

            let deviationHTML = '';
            if (prediction.deviation && prediction.deviation.length > 0) {
                deviationHTML = '<div class="rationale" style="margin-top: 1rem; background: rgba(52, 152, 219, 0.15);"><strong>üìä Deviation from Vegas:</strong>';
                prediction.deviation.forEach(dev => {
                    deviationHTML += `<div class="rationale-item">‚Üí ${dev}</div>`;
                });
                deviationHTML += '</div>';
            }

            let edgesHTML = '';
            if (prediction.edges.length > 0) {
                edgesHTML = '<div class="prediction-section"><div class="prediction-title">‚ö° Key Matchup Edges</div>';
                prediction.edges.forEach(edge => {
                    edgesHTML += `<div class="matchup-edge"><div class="edge-item">üî• ${edge}</div></div>`;
                });
                edgesHTML += '</div>';
            }

            let injuryHTML = '';
            if (prediction.injuries.home.length > 0 || prediction.injuries.away.length > 0) {
                injuryHTML = '<div class="prediction-section"><div class="prediction-title">üè• Key Injuries</div>';
                if (prediction.injuries.home.length > 0) {
                    injuryHTML += `<div class="injuries"><strong>${prediction.homeTeam}:</strong>`;
                    prediction.injuries.home.slice(0, 3).forEach(inj => {
                        const truncated = inj.headline.substring(0, 80) + (inj.headline.length > 80 ? '...' : '');
                        injuryHTML += `<div class="injury-item">‚Ä¢ <a href="${inj.link}" target="_blank" rel="noopener noreferrer">${truncated}</a></div>`;
                    });
                    injuryHTML += '</div>';
                }
                if (prediction.injuries.away.length > 0) {
                    injuryHTML += `<div class="injuries"><strong>${prediction.awayTeam}:</strong>`;
                    prediction.injuries.away.slice(0, 3).forEach(inj => {
                        const truncated = inj.headline.substring(0, 80) + (inj.headline.length > 80 ? '...' : '');
                        injuryHTML += `<div class="injury-item">‚Ä¢ <a href="${inj.link}" target="_blank" rel="noopener noreferrer">${truncated}</a></div>`;
                    });
                    injuryHTML += '</div>';
                }
                injuryHTML += '</div>';
            }

            return `
                <div id="${gameId}" class="game-card" style="background: linear-gradient(135deg, ${teamColor}22 0%, ${teamColor}44 100%); border: 2px solid ${teamColor}88;">
                    <div class="game-header" style="background-color: ${teamColor}ee;">
                        <div class="game-meta">
                            <div class="badge">üìÖ ${gameTime}</div>
                            ${weatherHTML}
                            <div class="badge ${confidenceClass}">${prediction.confidence.toUpperCase()}</div>
                        </div>
                        <div class="teams">
                            <div class="team">
                                ${awayLogo ? `<img src="${awayLogo}" alt="${prediction.awayTeam}" class="team-logo">` : ''}
                                <div>
                                    <div class="team-name">${prediction.awayTeam}</div>
                                    <div class="team-record">${prediction.awayRecord}</div>
                                </div>
                            </div>
                            <div class="vs">@</div>
                            <div class="team">
                                <div style="text-align: right;">
                                    <div class="team-name">${prediction.homeTeam}</div>
                                    <div class="team-record">${prediction.homeRecord}</div>
                                </div>
                                ${homeLogo ? `<img src="${homeLogo}" alt="${prediction.homeTeam}" class="team-logo">` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="game-body">
                        <div class="winner-section">
                            <div class="winner-label">üéØ OUR PREDICTION</div>
                            <div class="winner-name">${prediction.winner}</div>
                            <div class="confidence">Confidence: ${prediction.confidence}</div>
                            ${rationaleHTML}
                            ${deviationHTML}
                            ${calculationsHTML}
                        </div>

                        ${edgesHTML}
                        ${injuryHTML}

                        <div class="prediction-section">
                            <div class="prediction-title">üìä Score Predictions</div>
                            <div class="prediction-grid">
                                <div class="pred-stat">
                                    <div class="pred-label">üèà BRObet</div>
                                    <div class="pred-value" style="font-size: 1.5rem;">${prediction.homeScore} - ${prediction.awayScore}</div>
                                </div>
                                ${prediction.vegasHomeScore ? `
                                <div class="pred-stat">
                                    <div class="pred-label">üí∞ Vegas</div>
                                    <div class="pred-value" style="font-size: 1.5rem; color: #f39c12;">${prediction.vegasHomeScore} - ${prediction.vegasAwayScore}</div>
                                </div>
                                ` : ''}
                            </div>
                        </div>

                        ${prediction.vegasSpread !== 'N/A' ? `
                        <div class="prediction-section">
                            <div class="prediction-title">üí∞ Vegas Betting Lines</div>
                            <div class="stats-breakdown">
                                <div class="stat-row">
                                    <span>Spread:</span>
                                    <strong>${prediction.homeTeam} ${prediction.vegasSpread}</strong>
                                </div>
                                <div class="stat-row">
                                    <span>Over/Under:</span>
                                    <strong>${prediction.vegasTotal}</strong>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function savePrediction(gameId, gameDate, prediction) {
            const gameTime = new Date(gameDate);
            const now = new Date();

            if (now < gameTime) {
                predictions[gameId] = {
                    date: gameDate,
                    prediction: {
                        winner: prediction.winner,
                        homeTeam: prediction.homeTeam,
                        awayTeam: prediction.awayTeam,
                        homeScore: prediction.homeScore,
                        awayScore: prediction.awayScore
                    }
                };
                localStorage.setItem('nfl_predictions', JSON.stringify(predictions));
            }
        }

        // Note: Prediction checking is now handled by GitHub Actions
        // which updates results.json automatically

        // ===== AUTO-RETRY FOR FAILED PREDICTIONS =====
        function startRetryCountdown() {
            const errorCards = document.querySelectorAll('[id^="retry-timer-"]');
            if (errorCards.length === 0) return;

            let timeLeft = 15 * 60; // 15 minutes in seconds

            const interval = setInterval(() => {
                timeLeft--;

                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                errorCards.forEach(card => {
                    const countdownSpan = card.querySelector('[id^="countdown-"]');
                    if (countdownSpan) {
                        countdownSpan.textContent = display;
                    }
                });

                if (timeLeft <= 0) {
                    clearInterval(interval);
                    console.log('üîÑ Auto-retrying to fetch missing data...');
                    location.reload();
                }
            }, 1000);
        }

        // Start countdown if there are error cards
        setTimeout(startRetryCountdown, 1000);
    </script>
</body>
</html>
